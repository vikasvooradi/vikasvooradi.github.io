[
  {
    "platform": "DATIX",
    "title": "0123 Performance Rating Assignment",
    "repo": "datix",
    "path": "0123-performance-rating-assignment",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nSELECT\n    rating,\n    DENSE_RANK() OVER (ORDER BY rating DESC) AS position\nFROM evaluation\nORDER BY rating DESC;\n",
    "description": "<h2><a href=\"\">Performance Rating Assignment</a></h2><h3>Medium</h3><hr><p>Table: <code>Evaluation</code></p>\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| recordId    | int     |\n| rating      | decimal |\n+-------------+---------+\nrecordId is the primary key (column with unique values) for this table.\nEach row of this table stores the rating achieved in a performance evaluation. Rating is a floating point value with two decimal places.\n</pre>\n<p>&nbsp;</p>\n<p>Create a query to assign position numbers to the ratings. The position assignment must follow these criteria:</p>\n<ul>\n\t<li>Ratings must be positioned from the highest value to the lowest value.</li>\n\t<li>When two ratings share the same value, they must receive identical position numbers.</li>\n\t<li>Following identical ratings, the subsequent position number must be the immediate next integer. This means no gaps should exist in the position sequence.</li>\n</ul>\n<p>Return the result table ordered by <code>rating</code> in descending order.</p>\n<p>The result format is in the following example.</p>\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre>\n<strong>Input:</strong> \nEvaluation table:\n+----------+--------+\n| recordId | rating |\n+----------+--------+\n| 501      | 7.25   |\n| 502      | 8.40   |\n| 503      | 9.15   |\n| 504      | 7.90   |\n| 505      | 9.15   |\n| 506      | 8.40   |\n+----------+--------+\n<strong>Output:</strong> \n+--------+----------+\n| rating | position |\n+--------+----------+\n| 9.15   | 1        |\n| 9.15   | 1        |\n| 8.40   | 2        |\n| 8.40   | 2        |\n| 7.90   | 3        |\n| 7.25   | 3        |\n+--------+----------+\n\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0154 Merge Customer And Location Data",
    "repo": "datix",
    "path": "0154-merge-customer-and-location-data",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nSELECT\n    p.givenname,\n    p.surname,\n    a.cityname,\n    a.region\nFROM customer p\nLEFT JOIN location a\n    ON p.customerid = a.customerid ORDER BY\n    p.givenname;\n\n\n\n\n",
    "description": "<h2><a href=\"\">Merge Customer and Location Data</a></h2><h3>Easy</h3><hr><p>You are given two database tables containing customer and location information.</p>\n\n<h3>Table Schema</h3>\n\n<p>Table: <code>Customer</code></p>\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| customerId  | int     |\n| surname     | varchar |\n| givenName   | varchar |\n+-------------+---------+\ncustomerId serves as the primary key (unique identifier) for this table.\nThis table stores the unique identifier and full name details for various customers.\n</pre>\n\n<p>Table: <code>Location</code></p>\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| locationId  | int     |\n| customerId  | int     |\n| cityName    | varchar |\n| region      | varchar |\n+-------------+---------+\nlocationId serves as the primary key (unique identifier) for this table.\nEach record in this table contains the city and region information for a customer identified by customerId.\n</pre>\n\n<h3>Task</h3>\n<p>Create a query that retrieves the given name, surname, city name, and region for every customer in the <code>Customer</code> table. When a customer's location data is missing from the <code>Location</code> table, display <code>null</code> for the city and region fields.</p>\n\n<p>The output can be returned in <strong>any sequence</strong>.</p>\n\n<p>The expected output format is demonstrated below.</p>\n\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre>\n<strong>Input:</strong> \nCustomer table:\n+------------+---------+-----------+\n| customerId | surname | givenName |\n+------------+---------+-----------+\n| 101        | Smith   | James     |\n| 102        | Johnson | Maria     |\n+------------+---------+-----------+\nLocation table:\n+------------+------------+-------------+--------+\n| locationId | customerId | cityName    | region |\n+------------+------------+-------------+--------+\n| 5001       | 102        | Los Angeles | Texas  |\n| 5002       | 103        | Portland    | Oregon |\n+------------+------------+-------------+--------+\n<strong>Output:</strong> \n+-----------+---------+-------------+--------+\n| givenName | surname | cityName    | region |\n+-----------+---------+-------------+--------+\n| James     | Smith   | Null        | Null   |\n| Maria     | Johnson | Los Angeles | Texas  |\n+-----------+---------+-------------+--------+\n<strong>Explanation:</strong> \nCustomer with customerId = 101 has no corresponding entry in the Location table, therefore null values are returned for their cityName and region columns. The record with locationId = 5001 provides the location details for customerId = 102.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0158 Retrieve Runner Up Compensation",
    "repo": "datix",
    "path": "0158-retrieve-runner-up-compensation",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n/* Method 1 \n\nSELECT (\n    SELECT payamount\n    FROM (\n        SELECT DISTINCT payamount,\n               DENSE_RANK() OVER (ORDER BY payamount DESC) AS rnk\n        FROM worker\n    )\n    WHERE rnk = 2\n) AS SecondHighestSalary\nFROM dual;\n\n*/\n\n-- Method 2 \nSELECT\n    MAX(payamount) AS secondhighestsalary\nFROM\n    worker\nWHERE\n    payamount < (\n        SELECT\n            MAX(payamount)\n        FROM\n            worker\n    );\n    \n",
    "description": "<h2><a href=\"\">Retrieve Runner-Up Compensation</a></h2><h3>Medium</h3><hr><p>Table: <code>Worker</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| workerId    | int  |\n| payAmount   | int  |\n+-------------+------+\nworkerId is the primary key (column with unique values) for this table.\nEach row of this table contains information about the compensation amount of a worker.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to identify the second-largest <strong>distinct</strong> compensation amount from the <code>Worker</code> table. If no second-largest compensation exists, return <code>null</code>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nWorker table:\n+----------+-----------+\n| workerId | payAmount |\n+----------+-----------+\n| 501      | 45000     |\n| 502      | 67000     |\n| 503      | 89000     |\n+----------+-----------+\n<strong>Output:</strong> \n+--------------------+\n| SecondHighestPay   |\n+--------------------+\n| 67000              |\n+--------------------+\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nWorker table:\n+----------+-----------+\n| workerId | payAmount |\n+----------+-----------+\n| 501      | 45000     |\n+----------+-----------+\n<strong>Output:</strong> \n+--------------------+\n| SecondHighestPay   |\n+--------------------+\n| null               |\n+--------------------+\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0180 Consecutive Numbers",
    "repo": "datix",
    "path": "0180-consecutive-numbers",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect distinct num as ConsecutiveNums from (\n  select num,lag(num,1) over(order by id) as lag_1,lag(num,2) over(order by id) as lag_2 from logs \n) where num=lag_1 and lag_1=lag_2;\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/consecutive-numbers\">180. Consecutive Numbers</a></h2><h3>Medium</h3><hr><p>Table: <code>Logs</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| num         | varchar |\n+-------------+---------+\nIn SQL, id is the primary key for this table.\nid is an autoincrement column starting from 1.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Find all numbers that appear at least three times consecutively.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nLogs table:\n+----+-----+\n| id | num |\n+----+-----+\n| 1  | 1   |\n| 2  | 1   |\n| 3  | 1   |\n| 4  | 2   |\n| 5  | 1   |\n| 6  | 2   |\n| 7  | 2   |\n+----+-----+\n<strong>Output:</strong> \n+-----------------+\n| ConsecutiveNums |\n+-----------------+\n| 1               |\n+-----------------+\n<strong>Explanation:</strong> 1 is the only number that appears consecutively for at least three times.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0181 Employees Earning More Than Their Managers",
    "repo": "datix",
    "path": "0181-employees-earning-more-than-their-managers",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect m.name as employee from employee m join employee e on m.managerid = e.id where m.salary > e.salary\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/employees-earning-more-than-their-managers\">181. Employees Earning More Than Their Managers</a></h2><h3>Easy</h3><hr><p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| salary      | int     |\n| managerId   | int     |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID of an employee, their name, salary, and the ID of their manager.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution&nbsp;to find the employees who earn more than their managers.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+-----------+\n| id | name  | salary | managerId |\n+----+-------+--------+-----------+\n| 1  | Joe   | 70000  | 3         |\n| 2  | Henry | 80000  | 4         |\n| 3  | Sam   | 60000  | Null      |\n| 4  | Max   | 90000  | Null      |\n+----+-------+--------+-----------+\n<strong>Output:</strong> \n+----------+\n| Employee |\n+----------+\n| Joe      |\n+----------+\n<strong>Explanation:</strong> Joe is the only employee who earns more than his manager.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0182 Duplicate Emails",
    "repo": "datix",
    "path": "0182-duplicate-emails",
    "sqlCode": "/* Write your PL/SQL query statement below */\nselect email from person group by email having count(email) > 1;",
    "description": "<h2><a href=\"https://leetcode.com/problems/duplicate-emails\">182. Duplicate Emails</a></h2><h3>Easy</h3><hr><p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains an email. The emails will not contain uppercase letters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report all the duplicate emails. Note that it&#39;s guaranteed that the email&nbsp;field is not NULL.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----+---------+\n| id | email   |\n+----+---------+\n| 1  | a@b.com |\n| 2  | c@d.com |\n| 3  | a@b.com |\n+----+---------+\n<strong>Output:</strong> \n+---------+\n| Email   |\n+---------+\n| a@b.com |\n+---------+\n<strong>Explanation:</strong> a@b.com is repeated two times.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0183 Customers Who Never Order",
    "repo": "datix",
    "path": "0183-customers-who-never-order",
    "sqlCode": "/* Write your PL/SQL query statement below */\nselect c.name as customers from customers c left join orders o on c.id=o.customerid where o.customerid is null order by c.name",
    "description": "<h2><a href=\"https://leetcode.com/problems/customers-who-never-order\">183. Customers Who Never Order</a></h2><h3>Easy</h3><hr><p>Table: <code>Customers</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID and name of a customer.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Orders</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| customerId  | int  |\n+-------------+------+\nid is the primary key (column with unique values) for this table.\ncustomerId is a foreign key (reference columns) of the ID from the Customers table.\nEach row of this table indicates the ID of an order and the ID of the customer who ordered it.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all customers who never order anything.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nCustomers table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | Joe   |\n| 2  | Henry |\n| 3  | Sam   |\n| 4  | Max   |\n+----+-------+\nOrders table:\n+----+------------+\n| id | customerId |\n+----+------------+\n| 1  | 3          |\n| 2  | 1          |\n+----+------------+\n<strong>Output:</strong> \n+-----------+\n| Customers |\n+-----------+\n| Henry     |\n| Max       |\n+-----------+\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0184 Kth Largest Score Retrieval",
    "repo": "datix",
    "path": "0184-kth-largest-score-retrieval",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nCREATE FUNCTION getKthLargestScore(N IN NUMBER) RETURN NUMBER IS\nresult NUMBER;\nBEGIN\n    /* Write your PL/SQL query statement below */\n\n    BEGIN\n        select (SELECT points\n        FROM (\n            select points , row_number() over(order by points desc) as rn from (select distinct points from competitor)\n        )\n        WHERE rn = N) into result from dual;\n    EXCEPTION\n        WHEN NO_DATA_FOUND THEN\n            result := NULL;  \n    END;\n\n     RETURN result;\nEND; \n\n-- Calling \nselect getKthLargestScore(2) from dual;\n\n",
    "description": "<h2><a href=\"\">Kth Largest Score Retrieval</a></h2><h3>Medium</h3><hr><p>Table: <code>Competitor</code></p>\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| playerId    | int  |\n| points      | int  |\n+-------------+------+\nplayerId is the primary key (column with unique values) for this table.\nEach row of this table represents the total points earned by a competitor.\n</pre>\n<p>&nbsp;</p>\n<p>Develop a query to retrieve the <code>k<sup>th</sup></code> largest <strong>unique</strong> points value from the <code>Competitor</code> table. When fewer than <code>k</code> unique points values exist, the query should return&nbsp;<code>null</code>.</p>\n<p>The result format is in the following example.</p>\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre>\n<strong>Input:</strong> \nCompetitor table:\n+----------+--------+\n| playerId | points |\n+----------+--------+\n| 401      | 8500   |\n| 402      | 12000  |\n| 403      | 15500  |\n+----------+--------+\nk = 2\n<strong>Output:</strong> \n+----------------------+\n| getKthLargestScore(2)|\n+----------------------+\n| 12000                |\n+----------------------+\n</pre>\n<p><strong class=\"example\">Example 2:</strong></p>\n<pre>\n<strong>Input:</strong> \nCompetitor table:\n+----------+--------+\n| playerId | points |\n+----------+--------+\n| 401      | 8500   |\n+----------+--------+\nk = 2\n<strong>Output:</strong> \n+----------------------+\n| getKthLargestScore(2)|\n+----------------------+\n| null                 |\n+----------------------+\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0185 Department Top Three Salaries",
    "repo": "datix",
    "path": "0185-department-top-three-salaries",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect name as Department  , ename as Employee , salary from (\nselect d.id,d.name,e.name as ename,e.departmentid,e.salary,dense_rank() over(partition by d.name,e.departmentid order by d.name,e.departmentid,e.salary desc) as rnk\nfrom Department d join Employee e on d.id = e.departmentId  \n) where rnk < 4\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/department-top-three-salaries\">185. Department Top Three Salaries</a></h2><h3>Hard</h3><hr><p>Table: <code>Employee</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\nid is the primary key (column with unique values) for this table.\ndepartmentId is a foreign key (reference column) of the ID from the <code>Department </code>table.\nEach row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Department</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID of a department and its name.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>A company&#39;s executives are interested in seeing who earns the most money in each of the company&#39;s departments. A <strong>high earner</strong> in a department is an employee who has a salary in the <strong>top three unique</strong> salaries for that department.</p>\n\n<p>Write a solution to find the employees who are <strong>high earners</strong> in each of the departments.</p>\n\n<p>Return the result table <strong>in any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n+----+-------+--------+--------------+\nDepartment table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\n<strong>Output:</strong> \n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Joe      | 85000  |\n| IT         | Randy    | 85000  |\n| IT         | Will     | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\n<strong>Explanation:</strong> \nIn the IT department:\n- Max earns the highest unique salary\n- Both Randy and Joe earn the second-highest unique salary\n- Will earns the third-highest unique salary\n\nIn the Sales department:\n- Henry earns the highest salary\n- Sam earns the second-highest salary\n- There is no third-highest salary as there are only two employees\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>There are no employees with the <strong>exact</strong> same name, salary <em>and</em> department.</li>\n</ul>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0196 Delete Duplicate Emails",
    "repo": "datix",
    "path": "0196-delete-duplicate-emails",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nDELETE FROM Person\nWHERE id NOT IN (\n    SELECT MIN(id)\n    FROM Person\n    GROUP BY email\n);",
    "description": "<h2><a href=\"https://leetcode.com/problems/delete-duplicate-emails\">196. Delete Duplicate Emails</a></h2><h3>Easy</h3><hr><p>Table: <code>Person</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| email       | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains an email. The emails will not contain uppercase letters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to<strong> delete</strong> all duplicate emails, keeping only one unique email with the smallest <code>id</code>.</p>\n\n<p>For SQL users, please note that you are supposed to write a <code>DELETE</code> statement and not a <code>SELECT</code> one.</p>\n\n<p>For Pandas users, please note that you are supposed to modify <code>Person</code> in place.</p>\n\n<p>After running your script, the answer shown is the <code>Person</code> table. The driver will first compile and run your piece of code and then show the <code>Person</code> table. The final order of the <code>Person</code> table <strong>does not matter</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPerson table:\n+----+------------------+\n| id | email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n| 3  | john@example.com |\n+----+------------------+\n<strong>Output:</strong> \n+----+------------------+\n| id | email            |\n+----+------------------+\n| 1  | john@example.com |\n| 2  | bob@example.com  |\n+----+------------------+\n<strong>Explanation:</strong> john@example.com is repeated two times. We keep the row with the smallest Id = 1.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0197 Rising Temperature",
    "repo": "datix",
    "path": "0197-rising-temperature",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n/* Write your PL/SQL query statement below */\n\n\n    select id from (\n    select\n        id,\n        recordDate,\n        temperature,\n        lag(temperature,1) over(order by recordDate) as previous_tmp,\n        lag(recordDate,1) over(order by recordDate) as prev_date\n    from weather\n    ) where prev_date is not null and (recordDate - prev_date) = 1 and temperature > previous_tmp",
    "description": "<h2><a href=\"https://leetcode.com/problems/rising-temperature\">197. Rising Temperature</a></h2><h3>Easy</h3><hr><p>Table: <code>Weather</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| recordDate    | date    |\n| temperature   | int     |\n+---------------+---------+\nid is the column with unique values for this table.\nThere are no different rows with the same recordDate.\nThis table contains information about the temperature on a certain day.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all dates&#39; <code>id</code> with higher temperatures compared to its previous dates (yesterday).</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nWeather table:\n+----+------------+-------------+\n| id | recordDate | temperature |\n+----+------------+-------------+\n| 1  | 2015-01-01 | 10          |\n| 2  | 2015-01-02 | 25          |\n| 3  | 2015-01-03 | 20          |\n| 4  | 2015-01-04 | 30          |\n+----+------------+-------------+\n<strong>Output:</strong> \n+----+\n| id |\n+----+\n| 2  |\n| 4  |\n+----+\n<strong>Explanation:</strong> \nIn 2015-01-02, the temperature was higher than the previous day (10 -&gt; 25).\nIn 2015-01-04, the temperature was higher than the previous day (20 -&gt; 30).\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0199 Department Highest Salary",
    "repo": "datix",
    "path": "0199-department-highest-salary",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect Department,Employee,Salary from (\n    select Department,Employee,Salary,dense_rank() over(partition by Department order by Salary desc) as rank from \n    (\n        select d.name as Department, e.name  as Employee , e.salary as Salary \n        from Department d join Employee e on d.id=e.departmentId\n    ) \n) where rank=1;",
    "description": "<h2><a href=\"https://leetcode.com/problems/department-highest-salary\">199. Department Highest Salary</a></h2><h3>Medium</h3><hr><p>Table: <code>Employee</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\nid is the primary key (column with unique values) for this table.\ndepartmentId is a foreign key (reference columns) of the ID from the <code>Department </code>table.\nEach row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Department</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table. It is guaranteed that department name is not <code>NULL.</code>\nEach row of this table indicates the ID of a department and its name.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find employees who have the highest salary in each of the departments.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 70000  | 1            |\n| 2  | Jim   | 90000  | 1            |\n| 3  | Henry | 80000  | 2            |\n| 4  | Sam   | 60000  | 2            |\n| 5  | Max   | 90000  | 1            |\n+----+-------+--------+--------------+\nDepartment table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\n<strong>Output:</strong> \n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Jim      | 90000  |\n| Sales      | Henry    | 80000  |\n| IT         | Max      | 90000  |\n+------------+----------+--------+\n<strong>Explanation:</strong> Max and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0262 Trips And Users",
    "repo": "datix",
    "path": "0262-trips-and-users",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nWITH data AS (\n    SELECT \n        a.request_at,\n        a.status\n    FROM (\n        SELECT \n            t.id,\n            t.client_id,\n            t.driver_id,\n            t.status,\n            t.request_at,\n            u1.banned AS u1_banned\n        FROM trips t \n        JOIN users u1 \n            ON t.client_id = u1.users_id\n    ) a \n    JOIN users u2 \n        ON a.driver_id = u2.users_id\n    WHERE a.u1_banned = 'No'\n      AND u2.banned = 'No'\n      AND TO_DATE(a.request_at, 'YYYY-MM-DD')\n            BETWEEN DATE '2013-10-01' AND DATE '2013-10-03'\n),\ncalculate AS (\n    SELECT \n        request_at, \n        SUM(CASE WHEN status <> 'completed' THEN 1 ELSE 0 END) AS cancelled_count,\n        SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) AS completed_count \n    FROM data \n    GROUP BY request_at\n)\nSELECT \n    request_at AS \"Day\",\n    ROUND(\n        cancelled_count * 1.0 \n        / (cancelled_count + completed_count),\n        2\n    ) AS \"Cancellation Rate\"\nFROM calculate\nORDER BY request_at;\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/trips-and-users\">262. Trips and Users</a></h2><h3>Hard</h3><hr><p>Table: <code>Trips</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| client_id   | int      |\n| driver_id   | int      |\n| city_id     | int      |\n| status      | enum     |\n| request_at  | varchar  |     \n+-------------+----------+\nid is the primary key (column with unique values) for this table.\nThe table holds all taxi trips. Each trip has a unique id, while client_id and driver_id are foreign keys to the users_id at the Users table.\nStatus is an ENUM (category) type of (&#39;completed&#39;, &#39;cancelled_by_driver&#39;, &#39;cancelled_by_client&#39;).\n</pre>\n\n<p> </p>\n\n<p>Table: <code>Users</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| users_id    | int      |\n| banned      | enum     |\n| role        | enum     |\n+-------------+----------+\nusers_id is the primary key (column with unique values) for this table.\nThe table holds all users. Each user has a unique users_id, and role is an ENUM type of (&#39;client&#39;, &#39;driver&#39;, &#39;partner&#39;).\nbanned is an ENUM (category) type of (&#39;Yes&#39;, &#39;No&#39;).\n</pre>\n\n<p> </p>\n\n<p>The <strong>cancellation rate</strong> is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day.</p>\n\n<p>Write a solution to find the <strong>cancellation rate</strong> of requests with unbanned users (<strong>both client and driver must not be banned</strong>) each day between <code>&quot;2013-10-01&quot;</code> and <code>&quot;2013-10-03&quot;</code> with <strong>at least</strong> one trip. Round <code>Cancellation Rate</code> to <strong>two decimal</strong> points.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nTrips table:\n+----+-----------+-----------+---------+---------------------+------------+\n| id | client_id | driver_id | city_id | status              | request_at |\n+----+-----------+-----------+---------+---------------------+------------+\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\n+----+-----------+-----------+---------+---------------------+------------+\nUsers table:\n+----------+--------+--------+\n| users_id | banned | role   |\n+----------+--------+--------+\n| 1        | No     | client |\n| 2        | Yes    | client |\n| 3        | No     | client |\n| 4        | No     | client |\n| 10       | No     | driver |\n| 11       | No     | driver |\n| 12       | No     | driver |\n| 13       | No     | driver |\n+----------+--------+--------+\n<strong>Output:</strong> \n+------------+-------------------+\n| Day        | Cancellation Rate |\n+------------+-------------------+\n| 2013-10-01 | 0.33              |\n| 2013-10-02 | 0.00              |\n| 2013-10-03 | 0.50              |\n+------------+-------------------+\n<strong>Explanation:</strong> \nOn 2013-10-01:\n  - There were 4 requests in total, 2 of which were canceled.\n  - However, the request with Id=2 was made by a banned client (User_Id=2), so it is ignored in the calculation.\n  - Hence there are 3 unbanned requests in total, 1 of which was canceled.\n  - The Cancellation Rate is (1 / 3) = 0.33\nOn 2013-10-02:\n  - There were 3 requests in total, 0 of which were canceled.\n  - The request with Id=6 was made by a banned client, so it is ignored.\n  - Hence there are 2 unbanned requests in total, 0 of which were canceled.\n  - The Cancellation Rate is (0 / 2) = 0.00\nOn 2013-10-03:\n  - There were 3 requests in total, 1 of which was canceled.\n  - The request with Id=8 was made by a banned client, so it is ignored.\n  - Hence there are 2 unbanned request in total, 1 of which were canceled.\n  - The Cancellation Rate is (1 / 2) = 0.50\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0511 Game Play Analysis I",
    "repo": "datix",
    "path": "0511-game-play-analysis-i",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect player_id,to_char(first_login,'YYYY-MM-DD') as first_login from (select player_id, min(event_date) as first_login  from Activity group by player_id)",
    "description": "<h2><a href=\"https://leetcode.com/problems/game-play-analysis-i\">1179. Game Play Analysis I</a></h2><h3>Easy</h3><hr><p>Table: <code>Activity</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| player_id    | int     |\n| device_id    | int     |\n| event_date   | date    |\n| games_played | int     |\n+--------------+---------+\n(player_id, event_date) is the primary key (combination of columns with unique values) of this table.\nThis table shows the activity of players of some games.\nEach row is a record of a player who logged in and played a number of games (possibly 0) before logging out on someday using some device.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the <strong>first login date</strong> for each player.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nActivity table:\n+-----------+-----------+------------+--------------+\n| player_id | device_id | event_date | games_played |\n+-----------+-----------+------------+--------------+\n| 1         | 2         | 2016-03-01 | 5            |\n| 1         | 2         | 2016-05-02 | 6            |\n| 2         | 3         | 2017-06-25 | 1            |\n| 3         | 1         | 2016-03-02 | 0            |\n| 3         | 4         | 2018-07-03 | 5            |\n+-----------+-----------+------------+--------------+\n<strong>Output:</strong> \n+-----------+-------------+\n| player_id | first_login |\n+-----------+-------------+\n| 1         | 2016-03-01  |\n| 2         | 2017-06-25  |\n| 3         | 2016-03-02  |\n+-----------+-------------+\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0570 Managers With At Least 5 Direct Reports",
    "repo": "datix",
    "path": "0570-managers-with-at-least-5-direct-reports",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n/* Method 1 \n\nwith get_count as \n(\n    select managerid from employee \n    group by managerid having count(managerid) >= 5 order by managerid \n)\nselect name from employee where id in (select managerid from get_count) order by id\n\n*/\n\n\nselect e1.name from employee e1 join employee e2 on e1.id = e2.managerid group by e1.id, e1.name having count(e2.managerid) >=5\n\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/managers-with-at-least-5-direct-reports\">570. Managers with at Least 5 Direct Reports</a></h2><h3>Medium</h3><hr><p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| department  | varchar |\n| managerId   | int     |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the name of an employee, their department, and the id of their manager.\nIf managerId is null, then the employee does not have a manager.\nNo employee will be the manager of themself.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find managers with at least <strong>five direct reports</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+-----+-------+------------+-----------+\n| id  | name  | department | managerId |\n+-----+-------+------------+-----------+\n| 101 | John  | A          | null      |\n| 102 | Dan   | A          | 101       |\n| 103 | James | A          | 101       |\n| 104 | Amy   | A          | 101       |\n| 105 | Anne  | A          | 101       |\n| 106 | Ron   | B          | 101       |\n+-----+-------+------------+-----------+\n<strong>Output:</strong> \n+------+\n| name |\n+------+\n| John |\n+------+\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0577 Employee Bonus",
    "repo": "datix",
    "path": "0577-employee-bonus",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect e.name,b.bonus from Employee e left join Bonus b on e.empid=b.empid where b.bonus < 1000 or b.bonus is null",
    "description": "<h2><a href=\"https://leetcode.com/problems/employee-bonus\">577. Employee Bonus</a></h2><h3>Easy</h3><hr><p>Table: <code>Employee</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| empId       | int     |\n| name        | varchar |\n| supervisor  | int     |\n| salary      | int     |\n+-------------+---------+\nempId is the column with unique values for this table.\nEach row of this table indicates the name and the ID of an employee in addition to their salary and the id of their manager.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Bonus</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| empId       | int  |\n| bonus       | int  |\n+-------------+------+\nempId is the column of unique values for this table.\nempId is a foreign key (reference column) to empId from the Employee table.\nEach row of this table contains the id of an employee and their respective bonus.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the name and bonus amount of each employee who satisfies either of the following:</p>\n\n<ul>\n\t<li>The employee has a bonus <strong>less than</strong> <code>1000</code>.</li>\n\t<li>The employee did not get any bonus.</li>\n</ul>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+-------+--------+------------+--------+\n| empId | name   | supervisor | salary |\n+-------+--------+------------+--------+\n| 3     | Brad   | null       | 4000   |\n| 1     | John   | 3          | 1000   |\n| 2     | Dan    | 3          | 2000   |\n| 4     | Thomas | 3          | 4000   |\n+-------+--------+------------+--------+\nBonus table:\n+-------+-------+\n| empId | bonus |\n+-------+-------+\n| 2     | 500   |\n| 4     | 2000  |\n+-------+-------+\n<strong>Output:</strong> \n+------+-------+\n| name | bonus |\n+------+-------+\n| Brad | null  |\n| John | null  |\n| Dan  | 500   |\n+------+-------+\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0584 Find Customer Referee",
    "repo": "datix",
    "path": "0584-find-customer-referee",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect name from Customer where referee_id is null or referee_id !=2;",
    "description": "<h2><a href=\"https://leetcode.com/problems/find-customer-referee\">584. Find Customer Referee</a></h2><h3>Easy</h3><hr><p>Table: <code>Customer</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n| referee_id  | int     |\n+-------------+---------+\nIn SQL, id is the primary key column for this table.\nEach row of this table indicates the id of a customer, their name, and the id of the customer who referred them.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Find the names of the customer that are either:</p>\n\n<ol>\n\t<li><strong>referred by</strong>&nbsp;any&nbsp;customer with&nbsp;<code>id != 2</code>.</li>\n\t<li><strong>not referred by</strong> any customer.</li>\n</ol>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nCustomer table:\n+----+------+------------+\n| id | name | referee_id |\n+----+------+------------+\n| 1  | Will | null       |\n| 2  | Jane | null       |\n| 3  | Alex | 2          |\n| 4  | Bill | null       |\n| 5  | Zack | 1          |\n| 6  | Mark | 2          |\n+----+------+------------+\n<strong>Output:</strong> \n+------+\n| name |\n+------+\n| Will |\n| Jane |\n| Bill |\n| Zack |\n+------+\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0585 Investments In 2016",
    "repo": "datix",
    "path": "0585-investments-in-2016",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n-- Method 1 \n\n\n\nWITH insuranc_data_set_tiv_2015 AS (\n   \n   /* Getting only combination less then 2 \n\n    | PID | TIV_2015 | TIV_2016 | LAT | LON |\n    | --- | -------- | -------- | --- | --- |\n    | 1   | 10       | 5        | 10  | 10  |\n    | 3   | 10       | 30       | 20  | 20  |\n    | 4   | 10       | 40       | 40  | 40  |\n\n   */\n\n    SELECT\n        *\n    FROM\n        insurance\n    WHERE\n        tiv_2015 NOT IN (\n            SELECT\n                tiv_2015\n            FROM\n                insurance\n            GROUP BY\n                tiv_2015\n            HAVING\n                COUNT(tiv_2015) < 2\n        )\n    ORDER BY\n        pid\n), insuranc_data_set_lan_lon AS (\n\n    /* Getting only combination more then 1.\n       Make sure you do GROUP BY lat,lon and not (lat||lon) it will return output wrong - this test case fails.\n\n    | PID | TIV_2015 | TIV_2016 | LAT | LON |\n    | --- | -------- | -------- | --- | --- |\n    | 2   | 20       | 20       | 20  | 20  |\n    | 3   | 10       | 30       | 20  | 20  | \n    \n    */\n\n\n    SELECT\n        *\n    FROM\n        insurance\n    WHERE\n        (lat||lon ) IN (\n            SELECT\n                (lat||lon)\n            FROM\n                insurance\n            GROUP BY lat,lon\n            HAVING\n                COUNT((lat||lon)) > 1\n        )\n    ORDER BY\n        pid  \n                \n), union_both_combination_set AS (\n   /* Union both data set with both condition and apply second rule to exclude records where \n      both lat and lon is same. \n\n      | PID | TIV_2015 | TIV_2016 | LAT | LON |\n      | --- | -------- | -------- | --- | --- |\n      | 1   | 10       | 5        | 10  | 10  |\n      | 2   | 20       | 20       | 20  | 20  |\n      | 3   | 10       | 30       | 20  | 20  |\n      | 4   | 10       | 40       | 40  | 40  |\n\n      After applying not in with data set :   Insuranc_Data_Set_lan_lon\n\n      | PID | TIV_2015 | TIV_2016 | LAT | LON |\n      | --- | -------- | -------- | --- | --- |\n      | 1   | 10       | 5        | 10  | 10  |\n      | 4   | 10       | 40       | 40  | 40  |\n\n      Now apply sum on TIV_2016 and round of to 2 decimal places \n\n      | TIV_2016 |\n      | -------- |\n      | 45       |\n\n   */\n\n    SELECT\n        *\n    FROM\n        (\n            SELECT\n                *\n            FROM\n                insuranc_data_set_tiv_2015\n            UNION\n            SELECT\n                *\n            FROM\n                insuranc_data_set_lan_lon\n        )\n    WHERE\n        ( lat || lon ) NOT IN (\n            SELECT DISTINCT\n                ( lat\n                  || lon )\n            FROM\n                insuranc_data_set_lan_lon\n        ) \n)\nSELECT\n    round(SUM(tiv_2016),\n          2) AS tiv_2016\nFROM\n    union_both_combination_set;\n\n\n-- Method 2 \n/*\n\n| PID | TIV_2015 | LAT | LON | TIV_2016 | TIV_2015_COUNT1 | LAT_LON_COUNT2 |\n| --- | -------- | --- | --- | -------- | --------------- | -------------- |\n| 1   | 10       | 10  | 10  | 5        | 3               | 1              |\n| 4   | 10       | 40  | 40  | 40       | 3               | 1              |\n| 3   | 10       | 20  | 20  | 30       | 3               | 2              |\n| 2   | 20       | 20  | 20  | 20       | 1               | 2              |\n\n\n\nSELECT\n    round(SUM(tiv_2016),\n          2) AS tiv_2016\nFROM\n    (\n        SELECT\n            pid,\n            tiv_2015,\n            lat,\n            lon,\n            tiv_2016,\n            COUNT(*) OVER(PARTITION BY tiv_2015) AS tiv_2015_count1,\n            COUNT(*) OVER(PARTITION BY lat, lon) AS lat_lon_count2\n        FROM\n            insurance\n        ORDER BY\n            tiv_2015\n    )\nWHERE\n        lat_lon_count2 = 1\n    AND tiv_2015_count1 > 1;\n\t\n*/",
    "description": "<h2><a href=\"https://leetcode.com/problems/investments-in-2016\">585. Investments in 2016</a></h2><h3>Medium</h3><hr><p>Table: <code>Insurance</code></p>\n\n<pre>\n+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| pid         | int   |\n| tiv_2015    | float |\n| tiv_2016    | float |\n| lat         | float |\n| lon         | float |\n+-------------+-------+\npid is the primary key (column with unique values) for this table.\nEach row of this table contains information about one policy where:\npid is the policyholder&#39;s policy ID.\ntiv_2015 is the total investment value in 2015 and tiv_2016 is the total investment value in 2016.\nlat is the latitude of the policy holder&#39;s city. It&#39;s guaranteed that lat is not NULL.\nlon is the longitude of the policy holder&#39;s city. It&#39;s guaranteed that lon is not NULL.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the sum of all total investment values in 2016 <code>tiv_2016</code>, for all policyholders who:</p>\n\n<ul>\n\t<li>have the same <code>tiv_2015</code> value as one or more other policyholders, and</li>\n\t<li>are not located in the same city as any other policyholder (i.e., the (<code>lat, lon</code>) attribute pairs must be unique).</li>\n</ul>\n\n<p>Round <code>tiv_2016</code> to <strong>two decimal places</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nInsurance table:\n+-----+----------+----------+-----+-----+\n| pid | tiv_2015 | tiv_2016 | lat | lon |\n+-----+----------+----------+-----+-----+\n| 1   | 10       | 5        | 10  | 10  |\n| 2   | 20       | 20       | 20  | 20  |\n| 3   | 10       | 30       | 20  | 20  |\n| 4   | 10       | 40       | 40  | 40  |\n+-----+----------+----------+-----+-----+\n<strong>Output:</strong> \n+----------+\n| tiv_2016 |\n+----------+\n| 45.00    |\n+----------+\n<strong>Explanation:</strong> \nThe first record in the table, like the last record, meets both of the two criteria.\nThe tiv_2015 value 10 is the same as the third and fourth records, and its location is unique.\n\nThe second record does not meet any of the two criteria. Its tiv_2015 is not like any other policyholders and its location is the same as the third record, which makes the third record fail, too.\nSo, the result is the sum of tiv_2016 of the first and last record, which is 45.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0586 Customer Placing The Largest Number Of Orders",
    "repo": "datix",
    "path": "0586-customer-placing-the-largest-number-of-orders",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n-- The test cases are generated so that exactly one customer will have placed more orders than any other customer.\n\nselect customer_number from (select customer_number from orders \ngroup by customer_number order by count(customer_number) desc) where rownum=1;",
    "description": "<h2><a href=\"https://leetcode.com/problems/customer-placing-the-largest-number-of-orders\">586. Customer Placing the Largest Number of Orders</a></h2><h3>Easy</h3><hr><p>Table: <code>Orders</code></p>\n\n<pre>\n+-----------------+----------+\n| Column Name     | Type     |\n+-----------------+----------+\n| order_number    | int      |\n| customer_number | int      |\n+-----------------+----------+\norder_number is the primary key (column with unique values) for this table.\nThis table contains information about the order ID and the customer ID.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the <code>customer_number</code> for the customer who has placed <strong>the largest number of orders</strong>.</p>\n\n<p>The test cases are generated so that <strong>exactly one customer</strong> will have placed more orders than any other customer.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nOrders table:\n+--------------+-----------------+\n| order_number | customer_number |\n+--------------+-----------------+\n| 1            | 1               |\n| 2            | 2               |\n| 3            | 3               |\n| 4            | 3               |\n+--------------+-----------------+\n<strong>Output:</strong> \n+-----------------+\n| customer_number |\n+-----------------+\n| 3               |\n+-----------------+\n<strong>Explanation:</strong> \nThe customer with number 3 has two orders, which is greater than either customer 1 or 2 because each of them only has one order. \nSo the result is customer_number 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> What if more than one customer has the largest number of orders, can you find all the <code>customer_number</code> in this case?</p>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0595 Big Countries",
    "repo": "datix",
    "path": "0595-big-countries",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect name,population,area from world where area >= 3000000 or population >= 25000000;",
    "description": "<h2><a href=\"https://leetcode.com/problems/big-countries\">595. Big Countries</a></h2><h3>Easy</h3><hr><p>Table: <code>World</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| name        | varchar |\n| continent   | varchar |\n| area        | int     |\n| population  | int     |\n| gdp         | bigint  |\n+-------------+---------+\nname is the primary key (column with unique values) for this table.\nEach row of this table gives information about the name of a country, the continent to which it belongs, its area, the population, and its GDP value.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>A country is <strong>big</strong> if:</p>\n\n<ul>\n\t<li>it has an area of at least&nbsp;three million (i.e., <code>3000000 km<sup>2</sup></code>), or</li>\n\t<li>it has a population of at least&nbsp;twenty-five million (i.e., <code>25000000</code>).</li>\n</ul>\n\n<p>Write a solution to find the name, population, and area of the <strong>big countries</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nWorld table:\n+-------------+-----------+---------+------------+--------------+\n| name        | continent | area    | population | gdp          |\n+-------------+-----------+---------+------------+--------------+\n| Afghanistan | Asia      | 652230  | 25500100   | 20343000000  |\n| Albania     | Europe    | 28748   | 2831741    | 12960000000  |\n| Algeria     | Africa    | 2381741 | 37100000   | 188681000000 |\n| Andorra     | Europe    | 468     | 78115      | 3712000000   |\n| Angola      | Africa    | 1246700 | 20609294   | 100990000000 |\n+-------------+-----------+---------+------------+--------------+\n<strong>Output:</strong> \n+-------------+------------+---------+\n| name        | population | area    |\n+-------------+------------+---------+\n| Afghanistan | 25500100   | 652230  |\n| Algeria     | 37100000   | 2381741 |\n+-------------+------------+---------+\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0596 Classes With At Least 5 Students",
    "repo": "datix",
    "path": "0596-classes-with-at-least-5-students",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect class from courses group by class having count(class) >=5 order by class asc;",
    "description": "<h2><a href=\"https://leetcode.com/problems/classes-with-at-least-5-students\">596. Classes With at Least 5 Students</a></h2><h3>Easy</h3><hr><p>Table: <code>Courses</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| student     | varchar |\n| class       | varchar |\n+-------------+---------+\n(student, class) is the primary key (combination of columns with unique values) for this table.\nEach row of this table indicates the name of a student and the class in which they are enrolled.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all the classes that have <strong>at least five students</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nCourses table:\n+---------+----------+\n| student | class    |\n+---------+----------+\n| A       | Math     |\n| B       | English  |\n| C       | Math     |\n| D       | Biology  |\n| E       | Math     |\n| F       | Computer |\n| G       | Math     |\n| H       | Math     |\n| I       | Math     |\n+---------+----------+\n<strong>Output:</strong> \n+---------+\n| class   |\n+---------+\n| Math    |\n+---------+\n<strong>Explanation:</strong> \n- Math has 6 students, so we include it.\n- English has 1 student, so we do not include it.\n- Biology has 1 student, so we do not include it.\n- Computer has 1 student, so we do not include it.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0602 Friend Requests Ii Who Has The Most Friends",
    "repo": "datix",
    "path": "0602-friend-requests-ii-who-has-the-most-friends",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n-- Method 1\n\nSELECT id, num\nFROM (\n    SELECT id, COUNT(*) AS num\n    FROM (\n        SELECT requester_id AS id FROM RequestAccepted\n        UNION ALL\n        SELECT accepter_id AS id FROM RequestAccepted\n    ) all_ids\n    GROUP BY id\n    ORDER BY COUNT(*) DESC\n)\nWHERE ROWNUM = 1;\n\n\n/* \n\n-- Method 2 \n\nwith data as \n(\n    select id,count(*) as num from \n    (\n        select requester_id as id from RequestAccepted\n        union all \n        select accepter_id as id from RequestAccepted \n    ) group by id order by id\n), get_max as\n(\n  select max(num) as max_num from data \n)\nselect * from data where  num = (select max_num from get_max)\n\n*/",
    "description": "<h2><a href=\"https://leetcode.com/problems/friend-requests-ii-who-has-the-most-friends\">602. Friend Requests II: Who Has the Most Friends</a></h2><h3>Medium</h3><hr><p>Table: <code>RequestAccepted</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| requester_id   | int     |\n| accepter_id    | int     |\n| accept_date    | date    |\n+----------------+---------+\n(requester_id, accepter_id) is the primary key (combination of columns with unique values) for this table.\nThis table contains the ID of the user who sent the request, the ID of the user who received the request, and the date when the request was accepted.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the people who have the most friends and the most friends number.</p>\n\n<p>The test cases are generated so that only one person has the most friends.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nRequestAccepted table:\n+--------------+-------------+-------------+\n| requester_id | accepter_id | accept_date |\n+--------------+-------------+-------------+\n| 1            | 2           | 2016/06/03  |\n| 1            | 3           | 2016/06/08  |\n| 2            | 3           | 2016/06/08  |\n| 3            | 4           | 2016/06/09  |\n+--------------+-------------+-------------+\n<strong>Output:</strong> \n+----+-----+\n| id | num |\n+----+-----+\n| 3  | 3   |\n+----+-----+\n<strong>Explanation:</strong> \nThe person with id 3 is a friend of people 1, 2, and 4, so he has three friends in total, which is the most number than any others.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> In the real world, multiple people could have the same most number of friends. Could you find all these people in this case?</p>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0607 Sales Person",
    "repo": "datix",
    "path": "0607-sales-person",
    "sqlCode": "/* Write your PL/SQL query statement below\n\n-- sales_id -> pk -> tbl : salesperson\n-- com_id   -> pk -> tbl : company\n-- order_id -> pk -> tbl : orders\n\n-- Table relation\n\ncompany     -> comid(pk) - R - orders -> comid(fk)\nsalesperson -> sales_id  - R - orders -> sales_id(fk)\nID of company : com_id , ID of salesperson : sales_id , date of order : order_date , amount paid : amount\nname , com_id , sales_id , order_date , amount : one order made by salesperson\ncondition  : who did not have any orders related to the company with the name \"RED\"\npriority : comapnay -> order -> sales\nAmy , Mark , Alex : 2 , 3 , 5\n\n*/ -- select * from company c left join orders o on c.com_id = o.com_id left join salesperson s on o.sales_id = s.sales_id\n\n\nWITH DATA AS (\n  SELECT \n    c.com_id AS company_id, \n    c.name AS company_name, \n    o.order_date AS order_date, \n    o.amount AS order_amount, \n    o.sales_id AS sales_id \n  FROM \n    company c \n    LEFT JOIN orders o ON c.com_id = o.com_id\n), \nlist_all AS (\n  SELECT \n    DISTINCT s.name AS sname, \n    d.company_name AS dcname \n  FROM \n    salesperson s \n    LEFT JOIN DATA d ON s.sales_id = d.sales_id \n  ORDER BY \n    d.company_name\n), \nignore_multiple AS (\n  SELECT \n    sname ,dcname\n  FROM \n    list_all where dcname='RED'\n)\nSELECT \n  distinct name \nFROM \n  (\n    SELECT \n      sname AS name, \n      dcname AS company_name \n    FROM \n      (\n        SELECT \n          * \n        FROM \n          list_all \n        WHERE \n          sname NOT IN (\n            SELECT \n              sname \n            FROM \n              ignore_multiple\n          )\n      ) \n    WHERE \n      dcname != 'RED' \n      OR dcname IS NULL\n  );",
    "description": "<h2><a href=\"https://leetcode.com/problems/sales-person\">607. Sales Person</a></h2><h3>Easy</h3><hr><p>Table: <code>SalesPerson</code></p>\n\n<pre>\n+-----------------+---------+\n| Column Name     | Type    |\n+-----------------+---------+\n| sales_id        | int     |\n| name            | varchar |\n| salary          | int     |\n| commission_rate | int     |\n| hire_date       | date    |\n+-----------------+---------+\nsales_id is the primary key (column with unique values) for this table.\nEach row of this table indicates the name and the ID of a salesperson alongside their salary, commission rate, and hire date.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Company</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| com_id      | int     |\n| name        | varchar |\n| city        | varchar |\n+-------------+---------+\ncom_id is the primary key (column with unique values) for this table.\nEach row of this table indicates the name and the ID of a company and the city in which the company is located.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Orders</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| order_id    | int  |\n| order_date  | date |\n| com_id      | int  |\n| sales_id    | int  |\n| amount      | int  |\n+-------------+------+\norder_id is the primary key (column with unique values) for this table.\ncom_id is a foreign key (reference column) to com_id from the Company table.\nsales_id is a foreign key (reference column) to sales_id from the SalesPerson table.\nEach row of this table contains information about one order. This includes the ID of the company, the ID of the salesperson, the date of the order, and the amount paid.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the names of all the salespersons who did not have any orders related to the company with the name <strong>&quot;RED&quot;</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nSalesPerson table:\n+----------+------+--------+-----------------+------------+\n| sales_id | name | salary | commission_rate | hire_date  |\n+----------+------+--------+-----------------+------------+\n| 1        | John | 100000 | 6               | 4/1/2006   |\n| 2        | Amy  | 12000  | 5               | 5/1/2010   |\n| 3        | Mark | 65000  | 12              | 12/25/2008 |\n| 4        | Pam  | 25000  | 25              | 1/1/2005   |\n| 5        | Alex | 5000   | 10              | 2/3/2007   |\n+----------+------+--------+-----------------+------------+\nCompany table:\n+--------+--------+----------+\n| com_id | name   | city     |\n+--------+--------+----------+\n| 1      | RED    | Boston   |\n| 2      | ORANGE | New York |\n| 3      | YELLOW | Boston   |\n| 4      | GREEN  | Austin   |\n+--------+--------+----------+\nOrders table:\n+----------+------------+--------+----------+--------+\n| order_id | order_date | com_id | sales_id | amount |\n+----------+------------+--------+----------+--------+\n| 1        | 1/1/2014   | 3      | 4        | 10000  |\n| 2        | 2/1/2014   | 4      | 5        | 5000   |\n| 3        | 3/1/2014   | 1      | 1        | 50000  |\n| 4        | 4/1/2014   | 1      | 4        | 25000  |\n+----------+------------+--------+----------+--------+\n<strong>Output:</strong> \n+------+\n| name |\n+------+\n| Amy  |\n| Mark |\n| Alex |\n+------+\n<strong>Explanation:</strong> \nAccording to orders 3 and 4 in the Orders table, it is easy to tell that only salesperson John and Pam have sales to company RED, so we report all the other names in the table salesperson.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0608 Tree Node",
    "repo": "datix",
    "path": "0608-tree-node",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect \nid , \nCASE\n    when p_id is null then 'Root'\n    when id in (select p_id from tree) then 'Inner'\n    else 'Leaf' end as type \nfrom tree;\n\n\n\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/tree-node\">608. Tree Node</a></h2><h3>Medium</h3><hr><p>Table: <code>Tree</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| id          | int  |\n| p_id        | int  |\n+-------------+------+\nid is the column with unique values for this table.\nEach row of this table contains information about the id of a node and the id of its parent node in a tree.\nThe given structure is always a valid tree.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Each node in the tree can be one of three types:</p>\n\n<ul>\n\t<li><strong>&quot;Leaf&quot;</strong>: if the node is a leaf node.</li>\n\t<li><strong>&quot;Root&quot;</strong>: if the node is the root of the tree.</li>\n\t<li><strong>&quot;Inner&quot;</strong>: If the node is neither a leaf node nor a root node.</li>\n</ul>\n\n<p>Write a solution to report the type of each node in the tree.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/22/tree1.jpg\" style=\"width: 304px; height: 224px;\" />\n<pre>\n<strong>Input:</strong> \nTree table:\n+----+------+\n| id | p_id |\n+----+------+\n| 1  | null |\n| 2  | 1    |\n| 3  | 1    |\n| 4  | 2    |\n| 5  | 2    |\n+----+------+\n<strong>Output:</strong> \n+----+-------+\n| id | type  |\n+----+-------+\n| 1  | Root  |\n| 2  | Inner |\n| 3  | Leaf  |\n| 4  | Leaf  |\n| 5  | Leaf  |\n+----+-------+\n<strong>Explanation:</strong> \nNode 1 is the root node because its parent node is null and it has child nodes 2 and 3.\nNode 2 is an inner node because it has parent node 1 and child node 4 and 5.\nNodes 3, 4, and 5 are leaf nodes because they have parent nodes and they do not have child nodes.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/10/22/tree2.jpg\" style=\"width: 64px; height: 65px;\" />\n<pre>\n<strong>Input:</strong> \nTree table:\n+----+------+\n| id | p_id |\n+----+------+\n| 1  | null |\n+----+------+\n<strong>Output:</strong> \n+----+-------+\n| id | type  |\n+----+-------+\n| 1  | Root  |\n+----+-------+\n<strong>Explanation:</strong> If there is only one node on the tree, you only need to output its root attributes.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as <a href=\"https://leetcode.com/problems/binary-tree-nodes/description/\" target=\"_blank\"> 3054: Binary Tree Nodes.</a></p>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0610 Triangle Judgement",
    "repo": "datix",
    "path": "0610-triangle-judgement",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n-- To decide x , y , z values are called as triangle if it meets the formula : m < (x+y+z-m) \n-- m : maximum value amongst x y z \n\nselect x,y,z,case when m < calulated_value then 'Yes' else 'No' end as triangle from \n(\n    select x,y,z,greatest(x,y,z) as m , x+y+z-greatest(x,y,z) as calulated_value from Triangle \n);",
    "description": "<h2><a href=\"https://leetcode.com/problems/triangle-judgement\">610. Triangle Judgement</a></h2><h3>Easy</h3><hr><p>Table: <code>Triangle</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| x           | int  |\n| y           | int  |\n| z           | int  |\n+-------------+------+\nIn SQL, (x, y, z) is the primary key column for this table.\nEach row of this table contains the lengths of three line segments.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Report for every three line segments whether they can form a triangle.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nTriangle table:\n+----+----+----+\n| x  | y  | z  |\n+----+----+----+\n| 13 | 15 | 30 |\n| 10 | 20 | 15 |\n+----+----+----+\n<strong>Output:</strong> \n+----+----+----+----------+\n| x  | y  | z  | triangle |\n+----+----+----+----------+\n| 13 | 15 | 30 | No       |\n| 10 | 20 | 15 | Yes      |\n+----+----+----+----------+\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0619 Biggest Single Number",
    "repo": "datix",
    "path": "0619-biggest-single-number",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect nvl(max(num),NULL) as num from (select num from MyNumbers group by num having count(num) = 1)\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/biggest-single-number\">619. Biggest Single Number</a></h2><h3>Easy</h3><hr><p>Table: <code>MyNumbers</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| num         | int  |\n+-------------+------+\nThis table may contain duplicates (In other words, there is no primary key for this table in SQL).\nEach row of this table contains an integer.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>A <strong>single number</strong> is a number that appeared only once in the <code>MyNumbers</code> table.</p>\n\n<p>Find the largest <strong>single number</strong>. If there is no <strong>single number</strong>, report <code>null</code>.</p>\n\n<p>The result format is in the following example.</p>\n<ptable> </ptable>\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nMyNumbers table:\n+-----+\n| num |\n+-----+\n| 8   |\n| 8   |\n| 3   |\n| 3   |\n| 1   |\n| 4   |\n| 5   |\n| 6   |\n+-----+\n<strong>Output:</strong> \n+-----+\n| num |\n+-----+\n| 6   |\n+-----+\n<strong>Explanation:</strong> The single numbers are 1, 4, 5, and 6.\nSince 6 is the largest single number, we return it.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nMyNumbers table:\n+-----+\n| num |\n+-----+\n| 8   |\n| 8   |\n| 7   |\n| 7   |\n| 3   |\n| 3   |\n| 3   |\n+-----+\n<strong>Output:</strong> \n+------+\n| num  |\n+------+\n| null |\n+------+\n<strong>Explanation:</strong> There are no single numbers in the input table so we return null.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0620 Not Boring Movies",
    "repo": "datix",
    "path": "0620-not-boring-movies",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect id,movie,description,rating from cinema where mod(id,2) = 1 and description !='boring' order by rating desc;",
    "description": "<h2><a href=\"https://leetcode.com/problems/not-boring-movies\">620. Not Boring Movies</a></h2><h3>Easy</h3><hr><p>Table: <code>Cinema</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| id             | int      |\n| movie          | varchar  |\n| description    | varchar  |\n| rating         | float    |\n+----------------+----------+\nid is the primary key (column with unique values) for this table.\nEach row contains information about the name of a movie, its genre, and its rating.\nrating is a 2 decimal places float in the range [0, 10]\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the movies with an odd-numbered ID and a description that is not <code>&quot;boring&quot;</code>.</p>\n\n<p>Return the result table ordered by <code>rating</code> <strong>in descending order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nCinema table:\n+----+------------+-------------+--------+\n| id | movie      | description | rating |\n+----+------------+-------------+--------+\n| 1  | War        | great 3D    | 8.9    |\n| 2  | Science    | fiction     | 8.5    |\n| 3  | irish      | boring      | 6.2    |\n| 4  | Ice song   | Fantacy     | 8.6    |\n| 5  | House card | Interesting | 9.1    |\n+----+------------+-------------+--------+\n<strong>Output:</strong> \n+----+------------+-------------+--------+\n| id | movie      | description | rating |\n+----+------------+-------------+--------+\n| 5  | House card | Interesting | 9.1    |\n| 1  | War        | great 3D    | 8.9    |\n+----+------------+-------------+--------+\n<strong>Explanation:</strong> \nWe have three movies with odd-numbered IDs: 1, 3, and 5. The movie with ID = 3 is boring so we do not include it in the answer.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0626 Exchange Seats",
    "repo": "datix",
    "path": "0626-exchange-seats",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n/* Method 1 \n\nwith set_1 as\n(\n  select id,student,(id+1) as rnk from Seat  where mod(id,2) = 1\n), set_2 as\n(\n  select id,student,id-1 as rnk from Seat  where mod(id,2) = 0\n)\nselect row_number() over(order by rnk asc) as ID ,STUDENT from (select * from set_1 union select * from set_2) order by rnk\n\n*/\n\n/* Method 2 \n\nselect result as ID , student from (select id,student,nvl((COALESCE(odd_num, even_num)),(select max(id) from seat)) as result from \n(\n    select \n    id,student,mod(id,2) as mod_value ,\n    case when mod(id,2)=1 and id < (select max(id) from seat) then id+1 end as odd_num ,\n    case when mod(id,2)=0 then id-1 end as even_num\n    from seat order by id\n) ) order by result\n\n*/\n\n-- Method 3\nselect \ncase \n    when mod(id,2)=1 and id < (select max(id) from seat) then id+1 \n    when mod(id,2)=0 then id-1 else id \nend as id, student\nfrom seat order by id;",
    "description": "<h2><a href=\"https://leetcode.com/problems/exchange-seats\">626. Exchange Seats</a></h2><h3>Medium</h3><hr><p>Table: <code>Seat</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| student     | varchar |\n+-------------+---------+\nid is the primary key (unique value) column for this table.\nEach row of this table indicates the name and the ID of a student.\nThe ID sequence always starts from 1 and increments continuously.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to swap the seat id of every two consecutive students. If the number of students is odd, the id of the last student is not swapped.</p>\n\n<p>Return the result table ordered by <code>id</code> <strong>in ascending order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nSeat table:\n+----+---------+\n| id | student |\n+----+---------+\n| 1  | Abbot   |\n| 2  | Doris   |\n| 3  | Emerson |\n| 4  | Green   |\n| 5  | Jeames  |\n+----+---------+\n<strong>Output:</strong> \n+----+---------+\n| id | student |\n+----+---------+\n| 1  | Doris   |\n| 2  | Abbot   |\n| 3  | Green   |\n| 4  | Emerson |\n| 5  | Jeames  |\n+----+---------+\n<strong>Explanation:</strong> \nNote that if the number of students is odd, there is no need to change the last one&#39;s seat.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "0627 Swap Sex Of Employees",
    "repo": "datix",
    "path": "0627-swap-sex-of-employees",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nupdate salary set sex = CASE sex WHEN 'm' THEN 'f' else 'm' END;",
    "description": "<h2><a href=\"https://leetcode.com/problems/swap-sex-of-employees\">627. Swap Sex of Employees</a></h2><h3>Easy</h3><hr><p>Table: <code>Salary</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| name        | varchar  |\n| sex         | ENUM     |\n| salary      | int      |\n+-------------+----------+\nid is the primary key (column with unique values) for this table.\nThe sex column is ENUM (category) value of type (&#39;m&#39;, &#39;f&#39;).\nThe table contains information about an employee.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to swap all <code>&#39;f&#39;</code> and <code>&#39;m&#39;</code> values (i.e., change all <code>&#39;f&#39;</code> values to <code>&#39;m&#39;</code> and vice versa) with a <strong>single update statement</strong> and no intermediate temporary tables.</p>\n\n<p>Note that you must write a single update statement, <strong>do not</strong> write any select statement for this problem.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nSalary table:\n+----+------+-----+--------+\n| id | name | sex | salary |\n+----+------+-----+--------+\n| 1  | A    | m   | 2500   |\n| 2  | B    | f   | 1500   |\n| 3  | C    | m   | 5500   |\n| 4  | D    | f   | 500    |\n+----+------+-----+--------+\n<strong>Output:</strong> \n+----+------+-----+--------+\n| id | name | sex | salary |\n+----+------+-----+--------+\n| 1  | A    | f   | 2500   |\n| 2  | B    | m   | 1500   |\n| 3  | C    | f   | 5500   |\n| 4  | D    | m   | 500    |\n+----+------+-----+--------+\n<strong>Explanation:</strong> \n(1, A) and (3, C) were changed from &#39;m&#39; to &#39;f&#39;.\n(2, B) and (4, D) were changed from &#39;f&#39; to &#39;m&#39;.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1045 Customers Who Bought All Products",
    "repo": "datix",
    "path": "1045-customers-who-bought-all-products",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect CUSTOMER_ID from (select CUSTOMER_ID,count(CPRDT_KEY) as cnt_prd from \n(\n    select distinct \n    a.CUSTOMER_ID as CUSTOMER_ID,\n    a.PRODUCT_KEY as CPRDT_KEY\n    from customer a  \n    join product p on a.PRODUCT_KEY = p.PRODUCT_KEY \n) group by CUSTOMER_ID\n) where  cnt_prd = (select count(*) as cnt from product) order by CUSTOMER_ID",
    "description": "<h2><a href=\"https://leetcode.com/problems/customers-who-bought-all-products\">1135. Customers Who Bought All Products</a></h2><h3>Medium</h3><hr><p>Table: <code>Customer</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| customer_id | int     |\n| product_key | int     |\n+-------------+---------+\nThis table may contain duplicates rows. \n<code>customer_id</code> is not NULL<code>.</code>\nproduct_key is a foreign key (reference column) to <code>Product</code> table.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Product</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| product_key | int     |\n+-------------+---------+\nproduct_key is the primary key (column with unique values) for this table.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the customer ids from the <code>Customer</code> table that bought all the products in the <code>Product</code> table.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nCustomer table:\n+-------------+-------------+\n| customer_id | product_key |\n+-------------+-------------+\n| 1           | 5           |\n| 2           | 6           |\n| 3           | 5           |\n| 3           | 6           |\n| 1           | 6           |\n+-------------+-------------+\nProduct table:\n+-------------+\n| product_key |\n+-------------+\n| 5           |\n| 6           |\n+-------------+\n<strong>Output:</strong> \n+-------------+\n| customer_id |\n+-------------+\n| 1           |\n| 3           |\n+-------------+\n<strong>Explanation:</strong> \nThe customers who bought all the products (5 and 6) are customers with IDs 1 and 3.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1050 Actors And Directors Who Cooperated At Least Three Times",
    "repo": "datix",
    "path": "1050-actors-and-directors-who-cooperated-at-least-three-times",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n/*\n\nMethod 1 \nselect actor_id,director_id from \n(\n    select actor_id , director_id , count(actor_id) as cooperated from ActorDirector  group by actor_id , director_id \n    order by count(actor_id)  desc\n) where cooperated >=3\n\n*/\n\n-- Method 2 \nselect actor_id , director_id from ActorDirector group by actor_id , director_id having count(actor_id) >=3;\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times\">1136. Actors and Directors Who Cooperated At Least Three Times</a></h2><h3>Easy</h3><hr><p>Table: <code>ActorDirector</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| actor_id    | int     |\n| director_id | int     |\n| timestamp   | int     |\n+-------------+---------+\ntimestamp is the primary key (column with unique values) for this table.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all the pairs <code>(actor_id, director_id)</code> where the actor has cooperated with the director at least three times.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nActorDirector table:\n+-------------+-------------+-------------+\n| actor_id    | director_id | timestamp   |\n+-------------+-------------+-------------+\n| 1           | 1           | 0           |\n| 1           | 1           | 1           |\n| 1           | 1           | 2           |\n| 1           | 2           | 3           |\n| 1           | 2           | 4           |\n| 2           | 1           | 5           |\n| 2           | 1           | 6           |\n+-------------+-------------+-------------+\n<strong>Output:</strong> \n+-------------+-------------+\n| actor_id    | director_id |\n+-------------+-------------+\n| 1           | 1           |\n+-------------+-------------+\n<strong>Explanation:</strong> The only pair is (1, 1) where they cooperated exactly 3 times.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1068 Product Sales Analysis I",
    "repo": "datix",
    "path": "1068-product-sales-analysis-i",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect product_name,year,price from product p join Sales s on p.product_id=s.product_id  ",
    "description": "<h2><a href=\"https://leetcode.com/problems/product-sales-analysis-i\">1153. Product Sales Analysis I</a></h2><h3>Easy</h3><hr><p>Table: <code>Sales</code></p>\n\n<pre>\n+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| sale_id     | int   |\n| product_id  | int   |\n| year        | int   |\n| quantity    | int   |\n| price       | int   |\n+-------------+-------+\n(sale_id, year) is the primary key (combination of columns with unique values) of this table.\nproduct_id is a foreign key (reference column) to <code>Product</code> table.\nEach row of this table shows a sale on the product product_id in a certain year.\nNote that the price is per unit.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Product</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| product_id   | int     |\n| product_name | varchar |\n+--------------+---------+\nproduct_id is the primary key (column with unique values) of this table.\nEach row of this table indicates the product name of each product.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the <code>product_name</code>, <code>year</code>, and <code>price</code> for each <code>sale_id</code> in the <code>Sales</code> table.</p>\n\n<p>Return the resulting table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nSales table:\n+---------+------------+------+----------+-------+\n| sale_id | product_id | year | quantity | price |\n+---------+------------+------+----------+-------+ \n| 1       | 100        | 2008 | 10       | 5000  |\n| 2       | 100        | 2009 | 12       | 5000  |\n| 7       | 200        | 2011 | 15       | 9000  |\n+---------+------------+------+----------+-------+\nProduct table:\n+------------+--------------+\n| product_id | product_name |\n+------------+--------------+\n| 100        | Nokia        |\n| 200        | Apple        |\n| 300        | Samsung      |\n+------------+--------------+\n<strong>Output:</strong> \n+--------------+-------+-------+\n| product_name | year  | price |\n+--------------+-------+-------+\n| Nokia        | 2008  | 5000  |\n| Nokia        | 2009  | 5000  |\n| Apple        | 2011  | 9000  |\n+--------------+-------+-------+\n<strong>Explanation:</strong> \nFrom sale_id = 1, we can conclude that Nokia was sold for 5000 in the year 2008.\nFrom sale_id = 2, we can conclude that Nokia was sold for 5000 in the year 2009.\nFrom sale_id = 7, we can conclude that Apple was sold for 9000 in the year 2011.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1075 Project Employees I",
    "repo": "datix",
    "path": "1075-project-employees-i",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect project_id ,round(sum(EXPERIENCE_YEARS)/count(PROJECT_ID),2) as average_years  from (\nselect p.PROJECT_ID as project_id  , e.EXPERIENCE_YEARS as EXPERIENCE_YEARS  \nfrom employee e join project p on e.employee_id = p.employee_id order by p.PROJECT_ID\n) group by PROJECT_ID order by PROJECT_ID;",
    "description": "<h2><a href=\"https://leetcode.com/problems/project-employees-i\">1161. Project Employees I</a></h2><h3>Easy</h3><hr><p>Table: <code>Project</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| project_id  | int     |\n| employee_id | int     |\n+-------------+---------+\n(project_id, employee_id) is the primary key of this table.\nemployee_id is a foreign key to <code>Employee</code> table.\nEach row of this table indicates that the employee with employee_id is working on the project with project_id.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Employee</code></p>\n\n<pre>\n+------------------+---------+\n| Column Name      | Type    |\n+------------------+---------+\n| employee_id      | int     |\n| name             | varchar |\n| experience_years | int     |\n+------------------+---------+\nemployee_id is the primary key of this table. It&#39;s guaranteed that experience_years is not NULL.\nEach row of this table contains information about one employee.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write an SQL query that reports the <strong>average</strong> experience years of all the employees for each project, <strong>rounded to 2 digits</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The query result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nProject table:\n+-------------+-------------+\n| project_id  | employee_id |\n+-------------+-------------+\n| 1           | 1           |\n| 1           | 2           |\n| 1           | 3           |\n| 2           | 1           |\n| 2           | 4           |\n+-------------+-------------+\nEmployee table:\n+-------------+--------+------------------+\n| employee_id | name   | experience_years |\n+-------------+--------+------------------+\n| 1           | Khaled | 3                |\n| 2           | Ali    | 2                |\n| 3           | John   | 1                |\n| 4           | Doe    | 2                |\n+-------------+--------+------------------+\n<strong>Output:</strong> \n+-------------+---------------+\n| project_id  | average_years |\n+-------------+---------------+\n| 1           | 2.00          |\n| 2           | 2.50          |\n+-------------+---------------+\n<strong>Explanation:</strong> The average experience years for the first project is (3 + 2 + 1) / 3 = 2.00 and for the second project is (3 + 2) / 2 = 2.50\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1084 Sales Analysis Iii",
    "repo": "datix",
    "path": "1084-sales-analysis-iii",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect distinct p.product_id,p.product_name from Product p join Sales s on p.product_id = s.product_id \nwhere trunc(sale_date) between date '2019-01-01' and date '2019-03-31'\nand p.product_id not in (\n   select product_id from sales where trunc(sale_date) not between date '2019-01-01' and date '2019-03-31'\n);\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/sales-analysis-iii\">1174. Sales Analysis III</a></h2><h3>Easy</h3><hr><p>Table: <code>Product</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| product_id   | int     |\n| product_name | varchar |\n| unit_price   | int     |\n+--------------+---------+\nproduct_id is the primary key (column with unique values) of this table.\nEach row of this table indicates the name and the price of each product.\n</pre>\n\n<p>Table: <code>Sales</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| seller_id   | int     |\n| product_id  | int     |\n| buyer_id    | int     |\n| sale_date   | date    |\n| quantity    | int     |\n| price       | int     |\n+-------------+---------+\nThis table can have duplicate rows.\nproduct_id is a foreign key (reference column) to the Product table.\nEach row of this table contains some information about one sale.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to&nbsp;report&nbsp;the <strong>products</strong> that were <strong>only</strong> sold in the first quarter of <code>2019</code>. That is, between <code>2019-01-01</code> and <code>2019-03-31</code> inclusive.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nProduct table:\n+------------+--------------+------------+\n| product_id | product_name | unit_price |\n+------------+--------------+------------+\n| 1          | S8           | 1000       |\n| 2          | G4           | 800        |\n| 3          | iPhone       | 1400       |\n+------------+--------------+------------+\nSales table:\n+-----------+------------+----------+------------+----------+-------+\n| seller_id | product_id | buyer_id | sale_date  | quantity | price |\n+-----------+------------+----------+------------+----------+-------+\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\n| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |\n| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |\n+-----------+------------+----------+------------+----------+-------+\n<strong>Output:</strong> \n+-------------+--------------+\n| product_id  | product_name |\n+-------------+--------------+\n| 1           | S8           |\n+-------------+--------------+\n<strong>Explanation:</strong> \nThe product with id 1 was only sold in the spring of 2019.\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\nThe product with id 3 was sold after spring 2019.\nWe return only product 1 as it is the product that was only sold in the spring of 2019.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1141 User Activity For The Past 30 Days I",
    "repo": "datix",
    "path": "1141-user-activity-for-the-past-30-days-i",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\n\nselect \nto_char(TRUNC(activity_date), 'YYYY-MM-DD') as day,count(distinct user_id) as active_users\nfrom Activity where TRUNC(activity_date) BETWEEN DATE '2019-07-27' - 29 AND DATE '2019-07-27'\ngroup by activity_date order by activity_date",
    "description": "<h2><a href=\"https://leetcode.com/problems/user-activity-for-the-past-30-days-i\">1245. User Activity for the Past 30 Days I</a></h2><h3>Easy</h3><hr><p>Table: <code>Activity</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| user_id       | int     |\n| session_id    | int     |\n| activity_date | date    |\n| activity_type | enum    |\n+---------------+---------+\nThis table may have duplicate rows.\nThe activity_type column is an ENUM (category) of type (&#39;open_session&#39;, &#39;end_session&#39;, &#39;scroll_down&#39;, &#39;send_message&#39;).\nThe table shows the user activities for a social media website. \nNote that each session belongs to exactly one user.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the daily active user count for a period of <code>30</code> days ending <code>2019-07-27</code> inclusively. A user was active on someday if they made at least one activity on that day.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>Note: <strong>Any</strong> activity from (<code>&#39;open_session&#39;</code>, <code>&#39;end_session&#39;</code>, <code>&#39;scroll_down&#39;</code>, <code>&#39;send_message&#39;</code>) will be considered valid activity for a user to be considered active on a day.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nActivity table:\n+---------+------------+---------------+---------------+\n| user_id | session_id | activity_date | activity_type |\n+---------+------------+---------------+---------------+\n| 1       | 1          | 2019-07-20    | open_session  |\n| 1       | 1          | 2019-07-20    | scroll_down   |\n| 1       | 1          | 2019-07-20    | end_session   |\n| 2       | 4          | 2019-07-20    | open_session  |\n| 2       | 4          | 2019-07-21    | send_message  |\n| 2       | 4          | 2019-07-21    | end_session   |\n| 3       | 2          | 2019-07-21    | open_session  |\n| 3       | 2          | 2019-07-21    | send_message  |\n| 3       | 2          | 2019-07-21    | end_session   |\n| 4       | 3          | 2019-06-25    | open_session  |\n| 4       | 3          | 2019-06-25    | end_session   |\n+---------+------------+---------------+---------------+\n<strong>Output:</strong> \n+------------+--------------+ \n| day        | active_users |\n+------------+--------------+ \n| 2019-07-20 | 2            |\n| 2019-07-21 | 2            |\n+------------+--------------+ \n<strong>Explanation:</strong> Note that we do not care about days with zero active users.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1148 Article Views I",
    "repo": "datix",
    "path": "1148-article-views-i",
    "sqlCode": "/* Write your PL/SQL query statement below */\n \n-- Method 1  \n-- select author_id as id from Views where author_id=viewer_id group by author_id having count(VIEWER_ID) >=1 order by author_id;\n\n-- Method 2\nSELECT DISTINCT author_id as id from Views where author_id = viewer_id ORDER BY id;",
    "description": "<h2><a href=\"https://leetcode.com/problems/article-views-i\">1258. Article Views I</a></h2><h3>Easy</h3><hr><p>Table: <code>Views</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| article_id    | int     |\n| author_id     | int     |\n| viewer_id     | int     |\n| view_date     | date    |\n+---------------+---------+\nThere is no primary key (column with unique values) for this table, the table may have duplicate rows.\nEach row of this table indicates that some viewer viewed an article (written by some author) on some date. \nNote that equal author_id and viewer_id indicate the same person.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find all the authors that viewed at least one of their own articles.</p>\n\n<p>Return the result table sorted by <code>id</code> in ascending order.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nViews table:\n+------------+-----------+-----------+------------+\n| article_id | author_id | viewer_id | view_date  |\n+------------+-----------+-----------+------------+\n| 1          | 3         | 5         | 2019-08-01 |\n| 1          | 3         | 6         | 2019-08-02 |\n| 2          | 7         | 7         | 2019-08-01 |\n| 2          | 7         | 6         | 2019-08-02 |\n| 4          | 7         | 1         | 2019-07-22 |\n| 3          | 4         | 4         | 2019-07-21 |\n| 3          | 4         | 4         | 2019-07-21 |\n+------------+-----------+-----------+------------+\n<strong>Output:</strong> \n+------+\n| id   |\n+------+\n| 4    |\n| 7    |\n+------+\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1179 Reformat Department Table",
    "repo": "datix",
    "path": "1179-reformat-department-table",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n/* \n   ============================================================\n   ORACLE PIVOT  WORKING EXAMPLES WITH CORRECT OUTPUTS\n   ============================================================\n\n\n-- Verify raw data first (8 rows expected)\nSELECT * FROM sales_data ORDER BY emp_name, month;\n\nRAW DATA OUTPUT:\nEMP_NAME | REGION | MONTH | AMOUNT\n---------------------------------\nAmit     | NORTH  | JAN   | 1000\nAmit     | NORTH  | FEB   | 1500\nAmit     | NORTH  | MAR   | 1200\nNeha     | WEST   | JAN   | 1100\nNeha     | WEST   | FEB   | 1300\nRavi     | SOUTH  | JAN   | 800\nRavi     | SOUTH  | FEB   | 900\nRavi     | SOUTH  | MAR   | 1000\n\n\n========================================================\n   EXAMPLE 1: BASIC PIVOT (SUM) - MOST COMMON USE CASE\n======================================================== \n   \nSELECT * FROM (\n    SELECT emp_name, region, month, amount FROM sales_data\n)\nPIVOT (\n    SUM(amount)\n    FOR month IN ('JAN', 'FEB', 'MAR')\n) ORDER BY emp_name;\n\n  CORRECT OUTPUT:\nEMP_NAME | REGION | JAN  | FEB  | MAR\n------------------------------------\nAmit     | NORTH  | 1000 | 1500 | 1200\nNeha     | WEST   | 1100 | 1300 | NULL\nRavi     | SOUTH  | 800  | 900  | 1000\n\n\n ========================================================\n   EXAMPLE 2: COLUMN ALIASES (READABLE OUTPUT)\n   ======================================================== \nSELECT * FROM (\n    SELECT emp_name, region, month, amount FROM sales_data\n)\nPIVOT (  \n    SUM(amount)\n    FOR month IN ('JAN' AS JANUARY, 'FEB' AS FEBURARY, 'MAR' AS MARCH)\n) ORDER BY emp_name;\n\n\n\n  CORRECT OUTPUT:\nEMP_NAME | REGION | JANUARY | FEBURARY | MARCH\n-------------------------------------------\nAmit     | NORTH  | 1000    | 1500     | 1200\nNeha     | WEST   | 1100    | 1300     | NULL\nRavi     | SOUTH  | 800     | 900      | 1000\n\n\n ========================================================\n   EXAMPLE 3: USING COUNT (Transaction Count)\n   ======================================================== \nSELECT * FROM (\n    SELECT emp_name, region, month FROM sales_data \n)\nPIVOT (\n    COUNT(month)\n    FOR month IN ('JAN' AS JANUARY, 'FEB' AS FEBURARY, 'MAR' AS MARCH)\n) ORDER BY emp_name;\n\n\n\n  CORRECT OUTPUT:\nEMP_NAME | REGION | JANUARY | FEBURARY | MARCH\n-------------------------------------------\nAmit     | NORTH  | 1       | 1        | 1\nNeha     | WEST   | 1       | 1        | 0\nRavi     | SOUTH  | 1       | 1        | 1\n\n\n ========================================================\n   EXAMPLE 4: MAX on MONTH (Pivot Value Itself)\n   ======================================================== \nSELECT * FROM (\n    SELECT emp_name, region, month FROM sales_data \n)\nPIVOT (  \n    MAX(month)\n    FOR month IN ('JAN' AS JANUARY, 'FEB' AS FEBURARY, 'MAR' AS MARCH)\n) ORDER BY emp_name;\n\n  CORRECT OUTPUT:\nEMP_NAME | REGION | JANUARY | FEBURARY | MARCH\n-------------------------------------------\nAmit     | NORTH  | JAN     | FEB      | MAR\nNeha     | WEST   | JAN     | FEB      | NULL\nRavi     | SOUTH  | JAN     | FEB      | MAR\n\n\n\n\n ========================================================\n   EXAMPLE 5: MAX on AMOUNT (Highest Sale per Month)\n   ======================================================== \nSELECT * FROM (\n    SELECT emp_name, region, month, amount FROM sales_data \n)\nPIVOT (  \n    MAX(amount)\n    FOR month IN ('JAN' AS JANUARY, 'FEB' AS FEBURARY, 'MAR' AS MARCH)\n) ORDER BY emp_name;\n\n  CORRECT OUTPUT:\nEMP_NAME | REGION | JANUARY | FEBURARY | MARCH\n-------------------------------------------\nAmit     | NORTH  | 1000    | 1500     | 1200\nNeha     | WEST   | 1100    | 1300     | NULL\nRavi     | SOUTH  | 800     | 900      | 1000\n\n\n ========================================================\n   EXAMPLE 6: MULTIPLE AGGREGATES ( CORRECT SYNTAX)\n   ======================================================== \nSELECT * FROM (\n    SELECT emp_name, region, month, amount FROM sales_data \n)\nPIVOT ( \n    COUNT(amount) AS cnt,\n    SUM(amount)   AS sum_amt,\n    MAX(amount)   AS max_amt,\n    MIN(amount)   AS min_amt,\n    AVG(amount)   AS avg_amt\n    FOR month IN ('JAN' AS JANUARY, 'FEB' AS FEBURARY, 'MAR' AS MARCH)\n) ORDER BY emp_name;\n\n\n  CORRECT OUTPUT (13 Columns Total):\nEMP_NAME | REGION | JANUARY_CNT | JANUARY_SUM_AMT | JANUARY_MAX_AMT | JANUARY_MIN_AMT | JANUARY_AVG_AMT | FEBURARY_CNT | ...\n-----------------------------------------------------------------------------------------------------------\nAmit     | NORTH  | 1           | 1000            | 1000            | 1000            | 1000            | 1            | ...\nNeha     | WEST   | 1           | 1100            | 1100            | 1100            | 1100            | 1            | ...\nRavi     | SOUTH  | 1           | 800             | 800             | 800             | 800             | 1            | ...\n\n\n\n ============================================================\n    COMPLETE QUERY: PIVOT + NULL  0 \n   ============================================================ \n\nSELECT \n    emp_name,\n    region,\n    \n    -- JANUARY COLUMNS (All NULL  0)\n    NVL(JANUARY_CNT, 0) AS JANUARY_CNT,\n    NVL(JANUARY_SUM_AMT, 0) AS JANUARY_SUM_AMT,\n    NVL(JANUARY_MAX_AMT, 0) AS JANUARY_MAX_AMT,\n    NVL(JANUARY_MIN_AMT, 0) AS JANUARY_MIN_AMT,\n    NVL(JANUARY_AVG_AMT, 0) AS JANUARY_AVG_AMT,\n    \n    -- FEBRUARY COLUMNS (All NULL  0)\n    NVL(FEBURARY_CNT, 0) AS FEBURARY_CNT,\n    NVL(FEBURARY_SUM_AMT, 0) AS FEBURARY_SUM_AMT,\n    NVL(FEBURARY_MAX_AMT, 0) AS FEBURARY_MAX_AMT,\n    NVL(FEBURARY_MIN_AMT, 0) AS FEBURARY_MIN_AMT,\n    NVL(FEBURARY_AVG_AMT, 0) AS FEBURARY_AVG_AMT,\n    \n    -- MARCH COLUMNS (All NULL  0)\n    NVL(MARCH_CNT, 0) AS MARCH_CNT,\n    NVL(MARCH_SUM_AMT, 0) AS MARCH_SUM_AMT,\n    NVL(MARCH_MAX_AMT, 0) AS MARCH_MAX_AMT,\n    NVL(MARCH_MIN_AMT, 0) AS MARCH_MIN_AMT,\n    NVL(MARCH_AVG_AMT, 0) AS MARCH_AVG_AMT\n\nFROM (\n    SELECT emp_name, region, month, amount FROM sales_data \n)\nPIVOT ( \n    COUNT(amount) AS cnt,\n    SUM(amount)   AS sum_amt,\n    MAX(amount)   AS max_amt,\n    MIN(amount)   AS min_amt,\n    AVG(amount)   AS avg_amt  \n    FOR month IN ('JAN' AS JANUARY, 'FEB' AS FEBURARY, 'MAR' AS MARCH)\n) \nORDER BY emp_name;\n\n ============================================================\n    PERFECT OUTPUT (NO NULLS - All 0s):\n   ============================================================\n   EMP_NAME | REGION | JAN_CNT | JAN_SUM | ... | MAR_CNT | MAR_SUM | ...\n   ---------------------------------------------------------------\n   Amit     | NORTH  | 1       | 1000    | ... | 1       | 1200    | ...\n   Neha     | WEST   | 1       | 1100    | ... | 0       | 0       |  FIXED!\n   Ravi     | SOUTH  | 1       | 800     | ... | 1       | 1000    | ...\n   ============================================================ \n\n*/\n\n\n\n\n\nselect * from \n(\n    select id,revenue,month from Department\n) \nPIVOT (\n    SUM(revenue)\n    FOR month IN (\n        'Jan' AS Jan_Revenue,\n        'Feb' AS Feb_Revenue,\n        'Mar' AS Mar_Revenue,\n        'Apr' AS Apr_Revenue,\n        'May' AS May_Revenue,\n        'Jun' AS Jun_Revenue,\n        'Jul' AS Jul_Revenue,\n        'Aug' AS Aug_Revenue,\n        'Sep' AS Sep_Revenue,\n        'Oct' AS Oct_Revenue,\n        'Nov' AS Nov_Revenue,\n        'Dec' AS Dec_Revenue\n    )\n)\norder by id;",
    "description": "<h2><a href=\"https://leetcode.com/problems/reformat-department-table\">1301. Reformat Department Table</a></h2><h3>Easy</h3><hr><p>Table: <code>Department</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| revenue     | int     |\n| month       | varchar |\n+-------------+---------+\nIn SQL,(id, month) is the primary key of this table.\nThe table has information about the revenue of each department per month.\nThe month has values in [&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;].\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Reformat the table such that there is a department id column and a revenue column <strong>for each month</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nDepartment table:\n+------+---------+-------+\n| id   | revenue | month |\n+------+---------+-------+\n| 1    | 8000    | Jan   |\n| 2    | 9000    | Jan   |\n| 3    | 10000   | Feb   |\n| 1    | 7000    | Feb   |\n| 1    | 6000    | Mar   |\n+------+---------+-------+\n<strong>Output:</strong> \n+------+-------------+-------------+-------------+-----+-------------+\n| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |\n+------+-------------+-------------+-------------+-----+-------------+\n| 1    | 8000        | 7000        | 6000        | ... | null        |\n| 2    | 9000        | null        | null        | ... | null        |\n| 3    | null        | 10000       | null        | ... | null        |\n+------+-------------+-------------+-------------+-----+-------------+\n<strong>Explanation:</strong> The revenue from Apr to Dec is null.\nNote that the result table has 13 columns (1 for the department id + 12 for the months).\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1211 Queries Quality And Percentage",
    "repo": "datix",
    "path": "1211-queries-quality-and-percentage",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nwith cal_poor_query_percentage as\n(\n    select \n    query_name,\n    round((SUM(CASE WHEN rating < 3 THEN 1 ELSE 0 END) * 100.0) / count(*),2) as poor_query_percentage\n    from Queries group by query_name\n) , cal_quality as\n(\n    select \n    query_name,\n    round(sum(rating/position)/count(*),2) as quality\n    from Queries group by query_name\n)\nselect c1.query_name,c1.quality,c2.poor_query_percentage from cal_quality c1 join cal_poor_query_percentage c2\non c1.query_name = c2.query_name order by c1.query_name",
    "description": "<h2><a href=\"https://leetcode.com/problems/queries-quality-and-percentage\">1338. Queries Quality and Percentage</a></h2><h3>Easy</h3><hr><p>Table: <code>Queries</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| query_name  | varchar |\n| result      | varchar |\n| position    | int     |\n| rating      | int     |\n+-------------+---------+\nThis table may have duplicate rows.\nThis table contains information collected from some queries on a database.\nThe <code>position</code> column has a value from <strong>1</strong> to <strong>500</strong>.\nThe <code>rating</code> column has a value from <strong>1</strong> to <strong>5</strong>. Query with <code>rating</code> less than 3 is a poor query.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>We define query <code>quality</code> as:</p>\n\n<blockquote>\n<p>The average of the ratio between query rating and its position.</p>\n</blockquote>\n\n<p>We also define <code>poor query percentage</code> as:</p>\n\n<blockquote>\n<p>The percentage of all queries with rating less than 3.</p>\n</blockquote>\n\n<p>Write a solution to find each <code>query_name</code>, the <code>quality</code> and <code>poor_query_percentage</code>.</p>\n\n<p>Both <code>quality</code> and <code>poor_query_percentage</code> should be <strong>rounded to 2 decimal places</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nQueries table:\n+------------+-------------------+----------+--------+\n| query_name | result            | position | rating |\n+------------+-------------------+----------+--------+\n| Dog        | Golden Retriever  | 1        | 5      |\n| Dog        | German Shepherd   | 2        | 5      |\n| Dog        | Mule              | 200      | 1      |\n| Cat        | Shirazi           | 5        | 2      |\n| Cat        | Siamese           | 3        | 3      |\n| Cat        | Sphynx            | 7        | 4      |\n+------------+-------------------+----------+--------+\n<strong>Output:</strong> \n+------------+---------+-----------------------+\n| query_name | quality | poor_query_percentage |\n+------------+---------+-----------------------+\n| Dog        | 2.50    | 33.33                 |\n| Cat        | 0.66    | 33.33                 |\n+------------+---------+-----------------------+\n<strong>Explanation:</strong> \nDog queries quality is ((5 / 1) + (5 / 2) + (1 / 200)) / 3 = 2.50\nDog queries poor_ query_percentage is (1 / 3) * 100 = 33.33\n\nCat queries quality equals ((2 / 5) + (3 / 3) + (4 / 7)) / 3 = 0.66\nCat queries poor_ query_percentage is (1 / 3) * 100 = 33.33\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1251 Average Selling Price",
    "repo": "datix",
    "path": "1251-average-selling-price",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n/*\n-- Method 1 \n\nSELECT\n    p.product_id,\n    ROUND(\n        NVL(\n            SUM(u.units * p.price) \n            / SUM(u.units),\n        0),\n    2) AS average_price\nFROM prices p\nLEFT JOIN unitssold u\n    ON p.product_id = u.product_id\n   AND u.purchase_date BETWEEN p.start_date AND p.end_date\nGROUP BY p.product_id\nORDER BY p.product_id;\n\n*/\n\n-- Method 2 \n\nWITH data AS (\n    SELECT \n        p.product_id,\n        p.start_date,\n        p.end_date,\n        p.price,\n        u.purchase_date,\n        u.units\n    FROM prices p\n    LEFT JOIN unitssold u\n        ON p.product_id = u.product_id\n        -- LEFT JOIN:\n        -- Keeps all price rows even if there is no matching sale\n        -- If no sale exists, purchase_date and units become NULL\n),\n\ncal AS (\n    SELECT \n        product_id,\n        price,\n        NVL(units,0) AS units,\n        -- Convert NULL units (no sale) to 0\n\n        NVL(price,0) * NVL(units,0) AS sum_cal\n        -- Revenue per row = price  units\n    FROM data\n    WHERE purchase_date BETWEEN start_date AND end_date\n       OR purchase_date IS NULL\n       -- Keeps only sales that happened within the price period\n       -- OR keeps rows with no sales (NULL purchase_date)\n),\n\ntprice AS (\n    SELECT \n        product_id,\n        SUM(sum_cal) AS tprice\n        -- Total revenue per product\n    FROM cal\n    GROUP BY product_id\n),\n\noverall_sum AS (\n    SELECT \n        product_id,\n        SUM(units) AS osum\n        -- Total units sold per product\n    FROM unitssold\n    GROUP BY product_id\n)\n\nSELECT \n    p.product_id,\n\n    ROUND(\n        NVL(\n            t.tprice / NULLIF(o.osum, 0),\n            0\n        ),\n        2\n    ) AS average_price\n    -- NULLIF avoids division by zero\n    -- NVL returns 0 when there are no sales\n\nFROM prices p\nLEFT JOIN tprice t\n       ON p.product_id = t.product_id\n       -- Join revenue per product\nLEFT JOIN overall_sum o\n       ON p.product_id = o.product_id\n       -- Join total units per product\nGROUP BY p.product_id, t.tprice, o.osum\n       -- Removes duplicates caused by multiple price rows\nORDER BY p.product_id;\n\n\n\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/average-selling-price\">1390. Average Selling Price</a></h2><h3>Easy</h3><hr><p>Table: <code>Prices</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| product_id    | int     |\n| start_date    | date    |\n| end_date      | date    |\n| price         | int     |\n+---------------+---------+\n(product_id, start_date, end_date) is the primary key (combination of columns with unique values) for this table.\nEach row of this table indicates the price of the product_id in the period from start_date to end_date.\nFor each product_id there will be no two overlapping periods. That means there will be no two intersecting periods for the same product_id.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>UnitsSold</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| product_id    | int     |\n| purchase_date | date    |\n| units         | int     |\n+---------------+---------+\nThis table may contain duplicate rows.\nEach row of this table indicates the date, units, and product_id of each product sold. \n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the average selling price for each product. <code>average_price</code> should be <strong>rounded to 2 decimal places</strong>. If a product does not have any sold units, its average selling price is assumed to be 0.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPrices table:\n+------------+------------+------------+--------+\n| product_id | start_date | end_date   | price  |\n+------------+------------+------------+--------+\n| 1          | 2019-02-17 | 2019-02-28 | 5      |\n| 1          | 2019-03-01 | 2019-03-22 | 20     |\n| 2          | 2019-02-01 | 2019-02-20 | 15     |\n| 2          | 2019-02-21 | 2019-03-31 | 30     |\n+------------+------------+------------+--------+\nUnitsSold table:\n+------------+---------------+-------+\n| product_id | purchase_date | units |\n+------------+---------------+-------+\n| 1          | 2019-02-25    | 100   |\n| 1          | 2019-03-01    | 15    |\n| 2          | 2019-02-10    | 200   |\n| 2          | 2019-03-22    | 30    |\n+------------+---------------+-------+\n<strong>Output:</strong> \n+------------+---------------+\n| product_id | average_price |\n+------------+---------------+\n| 1          | 6.96          |\n| 2          | 16.96         |\n+------------+---------------+\n<strong>Explanation:</strong> \nAverage selling price = Total Price of Product / Number of products sold.\nAverage selling price for product 1 = ((100 * 5) + (15 * 20)) / 115 = 6.96\nAverage selling price for product 2 = ((200 * 15) + (30 * 30)) / 230 = 16.96\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1280 Students And Examinations",
    "repo": "datix",
    "path": "1280-students-and-examinations",
    "sqlCode": "/* Write your PL/SQL query statement below */WITH data AS (\n    SELECT\n        examinations.student_id,\n        subjects.subject_name\n    FROM\n             subjects right\n        JOIN examinations ON subjects.subject_name = examinations.subject_name\n    ORDER BY\n        examinations.student_id\n), cross_data AS (\n    SELECT\n        student_id,\n        subject_name,\n        0 AS attended_exams\n    FROM\n        students,\n        subjects\n    WHERE\n        student_id || subject_name NOT IN (\n            SELECT\n                student_id || subject_name\n            FROM\n                examinations\n        )\n    ORDER BY\n        student_id\n), combine_data AS (\n    SELECT\n        student_id,\n        subject_name,\n        attended_exams\n    FROM\n        (\n            SELECT\n                student_id,\n                subject_name,\n                COUNT(*) AS attended_exams\n            FROM\n                data\n            GROUP BY\n                student_id,\n                subject_name\n            ORDER BY\n                student_id\n        )\n    UNION\n    SELECT\n        student_id,\n        subject_name,\n        attended_exams\n    FROM\n        cross_data\n)\nSELECT\n    combine_data.student_id,\n    student_name,\n    subject_name,\n    attended_exams\nFROM\n         combine_data\n    JOIN students ON combine_data.student_id = students.student_id\nORDER BY\n    combine_data.student_id,\n    subject_name",
    "description": "<h2><a href=\"https://leetcode.com/problems/students-and-examinations\">1415. Students and Examinations</a></h2><h3>Easy</h3><hr><p>Table: <code>Students</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| student_id    | int     |\n| student_name  | varchar |\n+---------------+---------+\nstudent_id is the primary key (column with unique values) for this table.\nEach row of this table contains the ID and the name of one student in the school.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Subjects</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| subject_name | varchar |\n+--------------+---------+\nsubject_name is the primary key (column with unique values) for this table.\nEach row of this table contains the name of one subject in the school.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Examinations</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| student_id   | int     |\n| subject_name | varchar |\n+--------------+---------+\nThere is no primary key (column with unique values) for this table. It may contain duplicates.\nEach student from the Students table takes every course from the Subjects table.\nEach row of this table indicates that a student with ID student_id attended the exam of subject_name.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the number of times each student attended each exam.</p>\n\n<p>Return the result table ordered by <code>student_id</code> and <code>subject_name</code>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nStudents table:\n+------------+--------------+\n| student_id | student_name |\n+------------+--------------+\n| 1          | Alice        |\n| 2          | Bob          |\n| 13         | John         |\n| 6          | Alex         |\n+------------+--------------+\nSubjects table:\n+--------------+\n| subject_name |\n+--------------+\n| Math         |\n| Physics      |\n| Programming  |\n+--------------+\nExaminations table:\n+------------+--------------+\n| student_id | subject_name |\n+------------+--------------+\n| 1          | Math         |\n| 1          | Physics      |\n| 1          | Programming  |\n| 2          | Programming  |\n| 1          | Physics      |\n| 1          | Math         |\n| 13         | Math         |\n| 13         | Programming  |\n| 13         | Physics      |\n| 2          | Math         |\n| 1          | Math         |\n+------------+--------------+\n<strong>Output:</strong> \n+------------+--------------+--------------+----------------+\n| student_id | student_name | subject_name | attended_exams |\n+------------+--------------+--------------+----------------+\n| 1          | Alice        | Math         | 3              |\n| 1          | Alice        | Physics      | 2              |\n| 1          | Alice        | Programming  | 1              |\n| 2          | Bob          | Math         | 1              |\n| 2          | Bob          | Physics      | 0              |\n| 2          | Bob          | Programming  | 1              |\n| 6          | Alex         | Math         | 0              |\n| 6          | Alex         | Physics      | 0              |\n| 6          | Alex         | Programming  | 0              |\n| 13         | John         | Math         | 1              |\n| 13         | John         | Physics      | 1              |\n| 13         | John         | Programming  | 1              |\n+------------+--------------+--------------+----------------+\n<strong>Explanation:</strong> \nThe result table should contain all students and all subjects.\nAlice attended the Math exam 3 times, the Physics exam 2 times, and the Programming exam 1 time.\nBob attended the Math exam 1 time, the Programming exam 1 time, and did not attend the Physics exam.\nAlex did not attend any exams.\nJohn attended the Math exam 1 time, the Physics exam 1 time, and the Programming exam 1 time.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1327 List The Products Ordered In A Period",
    "repo": "datix",
    "path": "1327-list-the-products-ordered-in-a-period",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nwith get_distinct_order as\n(\n   select product_id,order_date,unit from orders \n)\nselect b.product_name as product_name,a.unit as unit from (select p.product_id as product_id ,sum(o.unit) as unit from products p join get_distinct_order o on \np.product_id=o.product_id where to_char(order_date,'YYYY-MM') ='2020-02'\ngroup by p.product_id having sum(o.unit) >=100\n) a join products b on a.product_id = b.product_id order by a.unit",
    "description": "<h2><a href=\"https://leetcode.com/problems/list-the-products-ordered-in-a-period\">1462. List the Products Ordered in a Period</a></h2><h3>Easy</h3><hr><p>Table: <code>Products</code></p>\n\n<pre>\n+------------------+---------+\n| Column Name      | Type    |\n+------------------+---------+\n| product_id       | int     |\n| product_name     | varchar |\n| product_category | varchar |\n+------------------+---------+\nproduct_id is the primary key (column with unique values) for this table.\nThis table contains data about the company&#39;s products.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Orders</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| product_id    | int     |\n| order_date    | date    |\n| unit          | int     |\n+---------------+---------+\nThis table may have duplicate rows.\nproduct_id is a foreign key (reference column) to the Products table.\nunit is the number of products ordered in order_date.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to get the names of products that have at least <code>100</code> units ordered in <strong>February 2020</strong> and their amount.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nProducts table:\n+-------------+-----------------------+------------------+\n| product_id  | product_name          | product_category |\n+-------------+-----------------------+------------------+\n| 1           | Leetcode Solutions    | Book             |\n| 2           | Jewels of Stringology | Book             |\n| 3           | HP                    | Laptop           |\n| 4           | Lenovo                | Laptop           |\n| 5           | Leetcode Kit          | T-shirt          |\n+-------------+-----------------------+------------------+\nOrders table:\n+--------------+--------------+----------+\n| product_id   | order_date   | unit     |\n+--------------+--------------+----------+\n| 1            | 2020-02-05   | 60       |\n| 1            | 2020-02-10   | 70       |\n| 2            | 2020-01-18   | 30       |\n| 2            | 2020-02-11   | 80       |\n| 3            | 2020-02-17   | 2        |\n| 3            | 2020-02-24   | 3        |\n| 4            | 2020-03-01   | 20       |\n| 4            | 2020-03-04   | 30       |\n| 4            | 2020-03-04   | 60       |\n| 5            | 2020-02-25   | 50       |\n| 5            | 2020-02-27   | 50       |\n| 5            | 2020-03-01   | 50       |\n+--------------+--------------+----------+\n<strong>Output:</strong> \n+--------------------+---------+\n| product_name       | unit    |\n+--------------------+---------+\n| Leetcode Solutions | 130     |\n| Leetcode Kit       | 100     |\n+--------------------+---------+\n<strong>Explanation:</strong> \nProducts with product_id = 1 is ordered in February a total of (60 + 70) = 130.\nProducts with product_id = 2 is ordered in February a total of 80.\nProducts with product_id = 3 is ordered in February a total of (2 + 3) = 5.\nProducts with product_id = 4 was not ordered in February 2020.\nProducts with product_id = 5 is ordered in February a total of (50 + 50) = 100.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1378 Replace Employee Id With The Unique Identifier",
    "repo": "datix",
    "path": "1378-replace-employee-id-with-the-unique-identifier",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect u.unique_id as unique_id , e.name as name\nfrom Employees e left join EmployeeUNI u on e.id = u.id order by name",
    "description": "<h2><a href=\"https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier\">1509. Replace Employee ID With The Unique Identifier</a></h2><h3>Easy</h3><hr><p>Table: <code>Employees</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| name          | varchar |\n+---------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains the id and the name of an employee in a company.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>EmployeeUNI</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| unique_id     | int     |\n+---------------+---------+\n(id, unique_id) is the primary key (combination of columns with unique values) for this table.\nEach row of this table contains the id and the corresponding unique id of an employee in the company.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to show the <strong>unique ID </strong>of each user, If a user does not have a unique ID replace just show <code>null</code>.</p>\n\n<p>Return the result table in <strong>any</strong> order.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployees table:\n+----+----------+\n| id | name     |\n+----+----------+\n| 1  | Alice    |\n| 7  | Bob      |\n| 11 | Meir     |\n| 90 | Winston  |\n| 3  | Jonathan |\n+----+----------+\nEmployeeUNI table:\n+----+-----------+\n| id | unique_id |\n+----+-----------+\n| 3  | 1         |\n| 11 | 2         |\n| 90 | 3         |\n+----+-----------+\n<strong>Output:</strong> \n+-----------+----------+\n| unique_id | name     |\n+-----------+----------+\n| null      | Alice    |\n| null      | Bob      |\n| 2         | Meir     |\n| 3         | Winston  |\n| 1         | Jonathan |\n+-----------+----------+\n<strong>Explanation:</strong> \nAlice and Bob do not have a unique ID, We will show null instead.\nThe unique ID of Meir is 2.\nThe unique ID of Winston is 3.\nThe unique ID of Jonathan is 1.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1393 Capital Gainloss",
    "repo": "datix",
    "path": "1393-capital-gainloss",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n/*\nSELECT\n    stock_name,\n    SUM(\n        CASE\n            WHEN operation = 'Sell' THEN price\n            WHEN operation = 'Buy'  THEN -price\n        END\n    ) AS capital_gain_loss\nFROM Stocks\nGROUP BY stock_name;\n\n*/\n\nSELECT\n    stock_name,\n    SUM(CASE WHEN operation = 'Sell' THEN price ELSE 0 END) - SUM(CASE WHEN operation = 'Buy'  THEN price ELSE 0 END)\n    AS capital_gain_loss\nFROM Stocks\nGROUP BY stock_name;\n\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/capital-gainloss\">1523. Capital Gain/Loss</a></h2><h3>Medium</h3><hr><p>Table: <code>Stocks</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| stock_name    | varchar |\n| operation     | enum    |\n| operation_day | int     |\n| price         | int     |\n+---------------+---------+\n(stock_name, operation_day) is the primary key (combination of columns with unique values) for this table.\nThe operation column is an ENUM (category) of type (&#39;Sell&#39;, &#39;Buy&#39;)\nEach row of this table indicates that the stock which has stock_name had an operation on the day operation_day with the price.\nIt is guaranteed that each &#39;Sell&#39; operation for a stock has a corresponding &#39;Buy&#39; operation in a previous day. It is also guaranteed that each &#39;Buy&#39; operation for a stock has a corresponding &#39;Sell&#39; operation in an upcoming day.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the <strong>Capital gain/loss</strong> for each stock.</p>\n\n<p>The <strong>Capital gain/loss</strong> of a stock is the total gain or loss after buying and selling the stock one or many times.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nStocks table:\n+---------------+-----------+---------------+--------+\n| stock_name    | operation | operation_day | price  |\n+---------------+-----------+---------------+--------+\n| Leetcode      | Buy       | 1             | 1000   |\n| Corona Masks  | Buy       | 2             | 10     |\n| Leetcode      | Sell      | 5             | 9000   |\n| Handbags      | Buy       | 17            | 30000  |\n| Corona Masks  | Sell      | 3             | 1010   |\n| Corona Masks  | Buy       | 4             | 1000   |\n| Corona Masks  | Sell      | 5             | 500    |\n| Corona Masks  | Buy       | 6             | 1000   |\n| Handbags      | Sell      | 29            | 7000   |\n| Corona Masks  | Sell      | 10            | 10000  |\n+---------------+-----------+---------------+--------+\n<strong>Output:</strong> \n+---------------+-------------------+\n| stock_name    | capital_gain_loss |\n+---------------+-------------------+\n| Corona Masks  | 9500              |\n| Leetcode      | 8000              |\n| Handbags      | -23000            |\n+---------------+-------------------+\n<strong>Explanation:</strong> \nLeetcode stock was bought at day 1 for 1000$ and was sold at day 5 for 9000$. Capital gain = 9000 - 1000 = 8000$.\nHandbags stock was bought at day 17 for 30000$ and was sold at day 29 for 7000$. Capital loss = 7000 - 30000 = -23000$.\nCorona Masks stock was bought at day 1 for 10$ and was sold at day 3 for 1010$. It was bought again at day 4 for 1000$ and was sold at day 5 for 500$. At last, it was bought at day 6 for 1000$ and was sold at day 10 for 10000$. Capital gain/loss is the sum of capital gains/losses for each (&#39;Buy&#39; --&gt; &#39;Sell&#39;) operation = (1010 - 10) + (500 - 1000) + (10000 - 1000) = 1000 - 500 + 9000 = 9500$.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1407 Top Travellers",
    "repo": "datix",
    "path": "1407-top-travellers",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect name , travelled_distance from (\n    select u.id,u.name as name , nvl(sum(r.distance),0) as travelled_distance from Users u left join Rides r on u.id = r.user_id \n    group by u.id,u.name  order by nvl(sum(r.distance),0) desc , u.name asc\n);\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/top-travellers\">1541. Top Travellers</a></h2><h3>Easy</h3><hr><p>Table: <code>Users</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| name          | varchar |\n+---------------+---------+\nid is the column with unique values for this table.\nname is the name of the user.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Rides</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| user_id       | int     |\n| distance      | int     |\n+---------------+---------+\nid is the column with unique values for this table.\nuser_id is the id of the user who traveled the distance &quot;distance&quot;.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution&nbsp;to report the distance traveled by each user.</p>\n\n<p>Return the result table ordered by <code>travelled_distance</code> in <strong>descending order</strong>, if two or more users traveled the same distance, order them by their <code>name</code> in <strong>ascending order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nUsers table:\n+------+-----------+\n| id   | name      |\n+------+-----------+\n| 1    | Alice     |\n| 2    | Bob       |\n| 3    | Alex      |\n| 4    | Donald    |\n| 7    | Lee       |\n| 13   | Jonathan  |\n| 19   | Elvis     |\n+------+-----------+\nRides table:\n+------+----------+----------+\n| id   | user_id  | distance |\n+------+----------+----------+\n| 1    | 1        | 120      |\n| 2    | 2        | 317      |\n| 3    | 3        | 222      |\n| 4    | 7        | 100      |\n| 5    | 13       | 312      |\n| 6    | 19       | 50       |\n| 7    | 7        | 120      |\n| 8    | 19       | 400      |\n| 9    | 7        | 230      |\n+------+----------+----------+\n<strong>Output:</strong> \n+----------+--------------------+\n| name     | travelled_distance |\n+----------+--------------------+\n| Elvis    | 450                |\n| Lee      | 450                |\n| Bob      | 317                |\n| Jonathan | 312                |\n| Alex     | 222                |\n| Alice    | 120                |\n| Donald   | 0                  |\n+----------+--------------------+\n<strong>Explanation:</strong> \nElvis and Lee traveled 450 miles, Elvis is the top traveler as his name is alphabetically smaller than Lee.\nBob, Jonathan, Alex, and Alice have only one ride and we just order them by the total distances of the ride.\nDonald did not have any rides, the distance traveled by him is 0.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1484 Group Sold Products By The Date",
    "repo": "datix",
    "path": "1484-group-sold-products-by-the-date",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect \n    to_char(sell_date,'YYYY-MM-DD') as sell_date,\n    SUM(COUNT(*)) OVER (PARTITION BY sell_date) AS num_sold,\n    LISTAGG(product, ',') WITHIN GROUP (ORDER BY product) AS products\nfrom (select distinct a.* from Activities a) group by sell_date order by sell_date",
    "description": "<h2><a href=\"https://leetcode.com/problems/group-sold-products-by-the-date\">1625. Group Sold Products By The Date</a></h2><h3>Easy</h3><hr><p>Table <code>Activities</code>:</p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| sell_date   | date    |\n| product     | varchar |\n+-------------+---------+\nThere is no primary key (column with unique values) for this table. It may contain duplicates.\nEach row of this table contains the product name and the date it was sold in a market.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find for each date the number of different products sold and their names.</p>\n\n<p>The sold products names for each date should be sorted lexicographically.</p>\n\n<p>Return the result table ordered by <code>sell_date</code>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nActivities table:\n+------------+------------+\n| sell_date  | product     |\n+------------+------------+\n| 2020-05-30 | Headphone  |\n| 2020-06-01 | Pencil     |\n| 2020-06-02 | Mask       |\n| 2020-05-30 | Basketball |\n| 2020-06-01 | Bible      |\n| 2020-06-02 | Mask       |\n| 2020-05-30 | T-Shirt    |\n+------------+------------+\n<strong>Output:</strong> \n+------------+----------+------------------------------+\n| sell_date  | num_sold | products                     |\n+------------+----------+------------------------------+\n| 2020-05-30 | 3        | Basketball,Headphone,T-shirt |\n| 2020-06-01 | 2        | Bible,Pencil                 |\n| 2020-06-02 | 1        | Mask                         |\n+------------+----------+------------------------------+\n<strong>Explanation:</strong> \nFor 2020-05-30, Sold items were (Headphone, Basketball, T-shirt), we sort them lexicographically and separate them by a comma.\nFor 2020-06-01, Sold items were (Pencil, Bible), we sort them lexicographically and separate them by a comma.\nFor 2020-06-02, the Sold item is (Mask), we just return it.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1517 Find Users With Valid E Mails",
    "repo": "datix",
    "path": "1517-find-users-with-valid-e-mails",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect user_id,name,mail from Users where regexp_like(mail,'^[a-zA-Z][a-zA-Z0-9_.-]*@leetcode\\.com$')\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/find-users-with-valid-e-mails\">1664. Find Users With Valid E-Mails</a></h2><h3>Easy</h3><hr><p>Table: <code>Users</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| user_id       | int     |\n| name          | varchar |\n| mail          | varchar |\n+---------------+---------+\nuser_id is the primary key (column with unique values) for this table.\nThis table contains information of the users signed up in a website. Some e-mails are invalid.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the users who have <strong>valid emails</strong>.</p>\n\n<p>A valid e-mail has a prefix name and a domain where:</p>\n\n<ul>\n\t<li><strong>The prefix name</strong> is a string that may contain letters (upper or lower case), digits, underscore <code>&#39;_&#39;</code>, period <code>&#39;.&#39;</code>, and/or dash <code>&#39;-&#39;</code>. The prefix name <strong>must</strong> start with a letter.</li>\n\t<li><strong>The domain</strong> is <code>&#39;@leetcode.com&#39;</code>.</li>\n</ul>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nUsers table:\n+---------+-----------+-------------------------+\n| user_id | name      | mail                    |\n+---------+-----------+-------------------------+\n| 1       | Winston   | winston@leetcode.com    |\n| 2       | Jonathan  | jonathanisgreat         |\n| 3       | Annabelle | bella-@leetcode.com     |\n| 4       | Sally     | sally.come@leetcode.com |\n| 5       | Marwan    | quarz#2020@leetcode.com |\n| 6       | David     | david69@gmail.com       |\n| 7       | Shapiro   | .shapo@leetcode.com     |\n+---------+-----------+-------------------------+\n<strong>Output:</strong> \n+---------+-----------+-------------------------+\n| user_id | name      | mail                    |\n+---------+-----------+-------------------------+\n| 1       | Winston   | winston@leetcode.com    |\n| 3       | Annabelle | bella-@leetcode.com     |\n| 4       | Sally     | sally.come@leetcode.com |\n+---------+-----------+-------------------------+\n<strong>Explanation:</strong> \nThe mail of user 2 does not have a domain.\nThe mail of user 5 has the # sign which is not allowed.\nThe mail of user 6 does not have the leetcode domain.\nThe mail of user 7 starts with a period.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1527 Patients With A Condition",
    "repo": "datix",
    "path": "1527-patients-with-a-condition",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect * from Patients where conditions LIKE 'DIAB1%' OR conditions LIKE '% DIAB1%';\n\n/*\nSELECT patient_id,patient_name,conditions\nFROM Patients\nWHERE REGEXP_LIKE(conditions, '(^| )DIAB1');\n*/",
    "description": "<h2><a href=\"https://leetcode.com/problems/patients-with-a-condition\">1670. Patients With a Condition</a></h2><h3>Easy</h3><hr><p>Table: <code>Patients</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| patient_id   | int     |\n| patient_name | varchar |\n| conditions   | varchar |\n+--------------+---------+\npatient_id is the primary key (column with unique values) for this table.\n&#39;conditions&#39; contains 0 or more code separated by spaces. \nThis table contains information of the patients in the hospital.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the patient_id, patient_name, and conditions of the patients who have Type I Diabetes. Type I Diabetes always starts with <code>DIAB1</code> prefix.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nPatients table:\n+------------+--------------+--------------+\n| patient_id | patient_name | conditions   |\n+------------+--------------+--------------+\n| 1          | Daniel       | YFEV COUGH   |\n| 2          | Alice        |              |\n| 3          | Bob          | DIAB100 MYOP |\n| 4          | George       | ACNE DIAB100 |\n| 5          | Alain        | DIAB201      |\n+------------+--------------+--------------+\n<strong>Output:</strong> \n+------------+--------------+--------------+\n| patient_id | patient_name | conditions   |\n+------------+--------------+--------------+\n| 3          | Bob          | DIAB100 MYOP |\n| 4          | George       | ACNE DIAB100 | \n+------------+--------------+--------------+\n<strong>Explanation:</strong> Bob and George both have a condition that starts with DIAB1.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1581 Customer Who Visited But Did Not Make Any Transactions",
    "repo": "datix",
    "path": "1581-customer-who-visited-but-did-not-make-any-transactions",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect customer_id , count(*) as count_no_trans  from Visits where visit_id not in ( select visit_id from Transactions)\ngroup by customer_id order by count(*) desc;",
    "description": "<h2><a href=\"https://leetcode.com/problems/customer-who-visited-but-did-not-make-any-transactions\">1724. Customer Who Visited but Did Not Make Any Transactions</a></h2><h3>Easy</h3><hr><p>Table: <code>Visits</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| visit_id    | int     |\n| customer_id | int     |\n+-------------+---------+\nvisit_id is the column with unique values for this table.\nThis table contains information about the customers who visited the mall.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Transactions</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| transaction_id | int     |\n| visit_id       | int     |\n| amount         | int     |\n+----------------+---------+\ntransaction_id is column with unique values for this table.\nThis table contains information about the transactions made during the visit_id.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a&nbsp;solution to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits.</p>\n\n<p>Return the result table sorted in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nVisits\n+----------+-------------+\n| visit_id | customer_id |\n+----------+-------------+\n| 1        | 23          |\n| 2        | 9           |\n| 4        | 30          |\n| 5        | 54          |\n| 6        | 96          |\n| 7        | 54          |\n| 8        | 54          |\n+----------+-------------+\nTransactions\n+----------------+----------+--------+\n| transaction_id | visit_id | amount |\n+----------------+----------+--------+\n| 2              | 5        | 310    |\n| 3              | 5        | 300    |\n| 9              | 5        | 200    |\n| 12             | 1        | 910    |\n| 13             | 2        | 970    |\n+----------------+----------+--------+\n<strong>Output:</strong> \n+-------------+----------------+\n| customer_id | count_no_trans |\n+-------------+----------------+\n| 54          | 2              |\n| 30          | 1              |\n| 96          | 1              |\n+-------------+----------------+\n<strong>Explanation:</strong> \nCustomer with id = 23 visited the mall once and made one transaction during the visit with id = 12.\nCustomer with id = 9 visited the mall once and made one transaction during the visit with id = 13.\nCustomer with id = 30 visited the mall once and did not make any transactions.\nCustomer with id = 54 visited the mall three times. During 2 visits they did not make any transactions, and during one visit they made 3 transactions.\nCustomer with id = 96 visited the mall once and did not make any transactions.\nAs we can see, users with IDs 30 and 96 visited the mall one time without making any transactions. Also, user 54 visited the mall twice and did not make any transactions.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1587 Bank Account Summary Ii",
    "repo": "datix",
    "path": "1587-bank-account-summary-ii",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect u.name,b.balance from Users u join \n(select account,balance from (select account, sum(amount) as balance from Transactions group by account order by account) where balance > 10000) b \non u.account = b.account;",
    "description": "<h2><a href=\"https://leetcode.com/problems/bank-account-summary-ii\">1734. Bank Account Summary II</a></h2><h3>Easy</h3><hr><p>Table: <code>Users</code></p>\n\n<pre>\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| account      | int     |\n| name         | varchar |\n+--------------+---------+\naccount is the primary key (column with unique values) for this table.\nEach row of this table contains the account number of each user in the bank.\nThere will be no two users having the same name in the table.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Transactions</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| trans_id      | int     |\n| account       | int     |\n| amount        | int     |\n| transacted_on | date    |\n+---------------+---------+\ntrans_id is the primary key (column with unique values) for this table.\nEach row of this table contains all changes made to all accounts.\namount is positive if the user received money and negative if they transferred money.\nAll accounts start with a balance of 0.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the name and balance of users with a balance higher than <code>10000</code>. The balance of an account is equal to the sum of the amounts of all transactions involving that account.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nUsers table:\n+------------+--------------+\n| account    | name         |\n+------------+--------------+\n| 900001     | Alice        |\n| 900002     | Bob          |\n| 900003     | Charlie      |\n+------------+--------------+\nTransactions table:\n+------------+------------+------------+---------------+\n| trans_id   | account    | amount     | transacted_on |\n+------------+------------+------------+---------------+\n| 1          | 900001     | 7000       |  2020-08-01   |\n| 2          | 900001     | 7000       |  2020-09-01   |\n| 3          | 900001     | -3000      |  2020-09-02   |\n| 4          | 900002     | 1000       |  2020-09-12   |\n| 5          | 900003     | 6000       |  2020-08-07   |\n| 6          | 900003     | 6000       |  2020-09-07   |\n| 7          | 900003     | -4000      |  2020-09-11   |\n+------------+------------+------------+---------------+\n<strong>Output:</strong> \n+------------+------------+\n| name       | balance    |\n+------------+------------+\n| Alice      | 11000      |\n+------------+------------+\n<strong>Explanation:</strong> \nAlice&#39;s balance is (7000 + 7000 - 3000) = 11000.\nBob&#39;s balance is 1000.\nCharlie&#39;s balance is (6000 + 6000 - 4000) = 8000.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1633 Percentage Of Users Attended A Contest",
    "repo": "datix",
    "path": "1633-percentage-of-users-attended-a-contest",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect \n    contest_id,\n    round((count(user_id) * 1.0 /(select count(*) from Users)) * 100.0,2) as percentage \nfrom Register group by contest_id\norder by percentage desc , contest_id asc;",
    "description": "<h2><a href=\"https://leetcode.com/problems/percentage-of-users-attended-a-contest\">1773. Percentage of Users Attended a Contest</a></h2><h3>Easy</h3><hr><p>Table: <code>Users</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| user_id     | int     |\n| user_name   | varchar |\n+-------------+---------+\nuser_id is the primary key (column with unique values) for this table.\nEach row of this table contains the name and the id of a user.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Register</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| contest_id  | int     |\n| user_id     | int     |\n+-------------+---------+\n(contest_id, user_id) is the primary key (combination of columns with unique values) for this table.\nEach row of this table contains the id of a user and the contest they registered into.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the percentage of the users registered in each contest rounded to <strong>two decimals</strong>.</p>\n\n<p>Return the result table ordered by <code>percentage</code> in <strong>descending order</strong>. In case of a tie, order it by <code>contest_id</code> in <strong>ascending order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nUsers table:\n+---------+-----------+\n| user_id | user_name |\n+---------+-----------+\n| 6       | Alice     |\n| 2       | Bob       |\n| 7       | Alex      |\n+---------+-----------+\nRegister table:\n+------------+---------+\n| contest_id | user_id |\n+------------+---------+\n| 215        | 6       |\n| 209        | 2       |\n| 208        | 2       |\n| 210        | 6       |\n| 208        | 6       |\n| 209        | 7       |\n| 209        | 6       |\n| 215        | 7       |\n| 208        | 7       |\n| 210        | 2       |\n| 207        | 2       |\n| 210        | 7       |\n+------------+---------+\n<strong>Output:</strong> \n+------------+------------+\n| contest_id | percentage |\n+------------+------------+\n| 208        | 100.0      |\n| 209        | 100.0      |\n| 210        | 100.0      |\n| 215        | 66.67      |\n| 207        | 33.33      |\n+------------+------------+\n<strong>Explanation:</strong> \nAll the users registered in contests 208, 209, and 210. The percentage is 100% and we sort them in the answer table by contest_id in ascending order.\nAlice and Alex registered in contest 215 and the percentage is ((2/3) * 100) = 66.67%\nBob registered in contest 207 and the percentage is ((1/3) * 100) = 33.33%\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1661 Average Time Of Process Per Machine",
    "repo": "datix",
    "path": "1661-average-time-of-process-per-machine",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n-- Method 1\nSELECT\n    machine_id,\n    round(abs(SUM((timestamp - lag_activity_type)) / COUNT(machine_id)),\n          3) AS processing_time\nFROM\n    (\n        SELECT\n            machine_id,\n            process_id,\n            activity_type,\n            timestamp,\n            LAG(timestamp, 1, NULL)\n            OVER(PARTITION BY machine_id, process_id\n                 ORDER BY\n                     machine_id, process_id,\n                     activity_type DESC\n            ) AS lag_activity_type\n        FROM\n            activity\n    )\nWHERE\n    lag_activity_type IS NOT NULL\nGROUP BY\n    machine_id;\n\n\n/*\n\n-- Method 2\nselect machine_id ,  round(sum(case when activity_type='end' then timestamp\nelse -timestamp end)/count(distinct process_id), 3) as processing_time\nfrom activity group by machine_id;\n\n*/",
    "description": "<h2><a href=\"https://leetcode.com/problems/average-time-of-process-per-machine\">1801. Average Time of Process per Machine</a></h2><h3>Easy</h3><hr><p>Table: <code>Activity</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| machine_id     | int     |\n| process_id     | int     |\n| activity_type  | enum    |\n| timestamp      | float   |\n+----------------+---------+\nThe table shows the user activities for a factory website.\n(machine_id, process_id, activity_type) is the primary key (combination of columns with unique values) of this table.\nmachine_id is the ID of a machine.\nprocess_id is the ID of a process running on the machine with ID machine_id.\nactivity_type is an ENUM (category) of type (&#39;start&#39;, &#39;end&#39;).\ntimestamp is a float representing the current time in seconds.\n&#39;start&#39; means the machine starts the process at the given timestamp and &#39;end&#39; means the machine ends the process at the given timestamp.\nThe &#39;start&#39; timestamp will always be before the &#39;end&#39; timestamp for every (machine_id, process_id) pair.\nIt is guaranteed that each (machine_id, process_id) pair has a &#39;start&#39; and &#39;end&#39; timestamp.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>There is a factory website that has several machines each running the <strong>same number of processes</strong>. Write a solution&nbsp;to find the <strong>average time</strong> each machine takes to complete a process.</p>\n\n<p>The time to complete a process is the <code>&#39;end&#39; timestamp</code> minus the <code>&#39;start&#39; timestamp</code>. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.</p>\n\n<p>The resulting table should have the <code>machine_id</code> along with the <strong>average time</strong> as <code>processing_time</code>, which should be <strong>rounded to 3 decimal places</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nActivity table:\n+------------+------------+---------------+-----------+\n| machine_id | process_id | activity_type | timestamp |\n+------------+------------+---------------+-----------+\n| 0          | 0          | start         | 0.712     |\n| 0          | 0          | end           | 1.520     |\n| 0          | 1          | start         | 3.140     |\n| 0          | 1          | end           | 4.120     |\n| 1          | 0          | start         | 0.550     |\n| 1          | 0          | end           | 1.550     |\n| 1          | 1          | start         | 0.430     |\n| 1          | 1          | end           | 1.420     |\n| 2          | 0          | start         | 4.100     |\n| 2          | 0          | end           | 4.512     |\n| 2          | 1          | start         | 2.500     |\n| 2          | 1          | end           | 5.000     |\n+------------+------------+---------------+-----------+\n<strong>Output:</strong> \n+------------+-----------------+\n| machine_id | processing_time |\n+------------+-----------------+\n| 0          | 0.894           |\n| 1          | 0.995           |\n| 2          | 1.456           |\n+------------+-----------------+\n<strong>Explanation:</strong> \nThere are 3 machines running 2 processes each.\nMachine 0&#39;s average time is ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894\nMachine 1&#39;s average time is ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995\nMachine 2&#39;s average time is ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1667 Fix Names In A Table",
    "repo": "datix",
    "path": "1667-fix-names-in-a-table",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect user_id,UPPER(substr(name,1,1)) || lower(substr(name,2)) as name from Users order by user_id;",
    "description": "<h2><a href=\"https://leetcode.com/problems/fix-names-in-a-table\">1811. Fix Names in a Table</a></h2><h3>Easy</h3><hr><p>Table: <code>Users</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| user_id        | int     |\n| name           | varchar |\n+----------------+---------+\nuser_id is the primary key (column with unique values) for this table.\nThis table contains the ID and the name of the user. The name consists of only lowercase and uppercase characters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to fix the names so that only the first character is uppercase and the rest are lowercase.</p>\n\n<p>Return the result table ordered by <code>user_id</code>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nUsers table:\n+---------+-------+\n| user_id | name  |\n+---------+-------+\n| 1       | aLice |\n| 2       | bOB   |\n+---------+-------+\n<strong>Output:</strong> \n+---------+-------+\n| user_id | name  |\n+---------+-------+\n| 1       | Alice |\n| 2       | Bob   |\n+---------+-------+\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1683 Invalid Tweets",
    "repo": "datix",
    "path": "1683-invalid-tweets",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect tweet_id from Tweets where length(content) > 15;",
    "description": "<h2><a href=\"https://leetcode.com/problems/invalid-tweets\">1827. Invalid Tweets</a></h2><h3>Easy</h3><hr><p>Table: <code>Tweets</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| tweet_id       | int     |\n| content        | varchar |\n+----------------+---------+\ntweet_id is the primary key (column with unique values) for this table.\ncontent consists of alphanumeric characters, &#39;!&#39;, or &#39; &#39; and no other special characters.\nThis table contains all the tweets in a social media app.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the IDs of the invalid tweets. The tweet is invalid if the number of characters used in the content of the tweet is <strong>strictly greater</strong> than <code>15</code>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nTweets table:\n+----------+-----------------------------------+\n| tweet_id | content                           |\n+----------+-----------------------------------+\n| 1        | Let us Code                       |\n| 2        | More than fifteen chars are here! |\n+----------+-----------------------------------+\n<strong>Output:</strong> \n+----------+\n| tweet_id |\n+----------+\n| 2        |\n+----------+\n<strong>Explanation:</strong> \nTweet 1 has length = 11. It is a valid tweet.\nTweet 2 has length = 33. It is an invalid tweet.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1693 Daily Leads And Partners",
    "repo": "datix",
    "path": "1693-daily-leads-and-partners",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect \n    to_char(date_id,'YYYY-MM-DD') as date_id,\n    make_name,\n    count(distinct lead_id) as unique_leads,\n    count(distinct partner_id)       as unique_partners\nfrom DailySales \n    group by date_id,make_name order by date_id;",
    "description": "<h2><a href=\"https://leetcode.com/problems/daily-leads-and-partners\">1837. Daily Leads and Partners</a></h2><h3>Easy</h3><hr><p>Table: <code>DailySales</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| date_id     | date    |\n| make_name   | varchar |\n| lead_id     | int     |\n| partner_id  | int     |\n+-------------+---------+\nThere is no primary key (column with unique values) for this table. It may contain duplicates.\nThis table contains the date and the name of the product sold and the IDs of the lead and partner it was sold to.\nThe name consists of only lowercase English letters.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>For each <code>date_id</code> and <code>make_name</code>, find the number of <strong>distinct</strong> <code>lead_id</code>&#39;s and <strong>distinct</strong> <code>partner_id</code>&#39;s.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nDailySales table:\n+-----------+-----------+---------+------------+\n| date_id   | make_name | lead_id | partner_id |\n+-----------+-----------+---------+------------+\n| 2020-12-8 | toyota    | 0       | 1          |\n| 2020-12-8 | toyota    | 1       | 0          |\n| 2020-12-8 | toyota    | 1       | 2          |\n| 2020-12-7 | toyota    | 0       | 2          |\n| 2020-12-7 | toyota    | 0       | 1          |\n| 2020-12-8 | honda     | 1       | 2          |\n| 2020-12-8 | honda     | 2       | 1          |\n| 2020-12-7 | honda     | 0       | 1          |\n| 2020-12-7 | honda     | 1       | 2          |\n| 2020-12-7 | honda     | 2       | 1          |\n+-----------+-----------+---------+------------+\n<strong>Output:</strong> \n+-----------+-----------+--------------+-----------------+\n| date_id   | make_name | unique_leads | unique_partners |\n+-----------+-----------+--------------+-----------------+\n| 2020-12-8 | toyota    | 2            | 3               |\n| 2020-12-7 | toyota    | 1            | 2               |\n| 2020-12-8 | honda     | 2            | 2               |\n| 2020-12-7 | honda     | 3            | 2               |\n+-----------+-----------+--------------+-----------------+\n<strong>Explanation:</strong> \nFor 2020-12-8, toyota gets leads = [0, 1] and partners = [0, 1, 2] while honda gets leads = [1, 2] and partners = [1, 2].\nFor 2020-12-7, toyota gets leads = [0] and partners = [1, 2] while honda gets leads = [0, 1, 2] and partners = [1, 2].\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1729 Find Followers Count",
    "repo": "datix",
    "path": "1729-find-followers-count",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect user_id,count(user_id) as followers_count from Followers group by user_id order by user_id;",
    "description": "<h2><a href=\"https://leetcode.com/problems/find-followers-count\">1877. Find Followers Count</a></h2><h3>Easy</h3><hr><p>Table: <code>Followers</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| user_id     | int  |\n| follower_id | int  |\n+-------------+------+\n(user_id, follower_id) is the primary key (combination of columns with unique values) for this table.\nThis table contains the IDs of a user and a follower in a social media app where the follower follows the user.</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution that will, for each user, return the number of followers.</p>\n\n<p>Return the result table ordered by <code>user_id</code> in ascending order.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nFollowers table:\n+---------+-------------+\n| user_id | follower_id |\n+---------+-------------+\n| 0       | 1           |\n| 1       | 0           |\n| 2       | 0           |\n| 2       | 1           |\n+---------+-------------+\n<strong>Output:</strong> \n+---------+----------------+\n| user_id | followers_count|\n+---------+----------------+\n| 0       | 1              |\n| 1       | 1              |\n| 2       | 2              |\n+---------+----------------+\n<strong>Explanation:</strong> \nThe followers of 0 are {1}\nThe followers of 1 are {0}\nThe followers of 2 are {0,1}\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1731 The Number Of Employees Which Report To Each Employee",
    "repo": "datix",
    "path": "1731-the-number-of-employees-which-report-to-each-employee",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect e.employee_id,e.name,r.reports_count,r.average_age from Employees e join \n(\n    select \n        reports_to, \n        count(reports_to) as reports_count,\n        round(avg(age))   as average_age\n    from Employees where reports_to is not null group by reports_to order by reports_to\n) r on e.employee_id=r.reports_to order by employee_id;",
    "description": "<h2><a href=\"https://leetcode.com/problems/the-number-of-employees-which-report-to-each-employee\">1882. The Number of Employees Which Report to Each Employee</a></h2><h3>Easy</h3><hr><p>Table: <code>Employees</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| employee_id | int      |\n| name        | varchar  |\n| reports_to  | int      |\n| age         | int      |\n+-------------+----------+\nemployee_id is the column with unique values for this table.\nThis table contains information about the employees and the id of the manager they report to. Some employees do not report to anyone (reports_to is null). \n</pre>\n\n<p>&nbsp;</p>\n\n<p>For this problem, we will consider a <strong>manager</strong> an employee who has at least 1 other employee reporting to them.</p>\n\n<p>Write a solution to report the ids and the names of all <strong>managers</strong>, the number of employees who report <strong>directly</strong> to them, and the average age of the reports rounded to the nearest integer.</p>\n\n<p>Return the result table ordered by <code>employee_id</code>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployees table:\n+-------------+---------+------------+-----+\n| employee_id | name    | reports_to | age |\n+-------------+---------+------------+-----+\n| 9           | Hercy   | null       | 43  |\n| 6           | Alice   | 9          | 41  |\n| 4           | Bob     | 9          | 36  |\n| 2           | Winston | null       | 37  |\n+-------------+---------+------------+-----+\n<strong>Output:</strong> \n+-------------+-------+---------------+-------------+\n| employee_id | name  | reports_count | average_age |\n+-------------+-------+---------------+-------------+\n| 9           | Hercy | 2             | 39          |\n+-------------+-------+---------------+-------------+\n<strong>Explanation:</strong> Hercy has 2 people report directly to him, Alice and Bob. Their average age is (41+36)/2 = 38.5, which is 39 after rounding it to the nearest integer.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployees table:\n+-------------+---------+------------+-----+ \n| employee_id | name &nbsp; &nbsp;| reports_to | age |\n|-------------|---------|------------|-----|\n| 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Michael | null &nbsp; &nbsp; &nbsp; | 45 &nbsp;|\n| 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Alice &nbsp; | 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 38 &nbsp;|\n| 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Bob &nbsp; &nbsp; | 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 42 &nbsp;|\n| 4 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Charlie | 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 34 &nbsp;|\n| 5 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | David &nbsp; | 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 40 &nbsp;|\n| 6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Eve &nbsp; &nbsp; | 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 37 &nbsp;|\n| 7 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Frank &nbsp; | null &nbsp; &nbsp; &nbsp; | 50 &nbsp;|\n| 8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Grace &nbsp; | null &nbsp; &nbsp; &nbsp; | 48 &nbsp;|\n+-------------+---------+------------+-----+ \n<strong>Output:</strong> \n+-------------+---------+---------------+-------------+\n| employee_id | name &nbsp; &nbsp;| reports_count | average_age |\n| ----------- | ------- | ------------- | ----------- |\n| 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Michael | 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 40 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n| 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Alice &nbsp; | 2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 37 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n| 3 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Bob &nbsp; &nbsp; | 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | 37 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|\n+-------------+---------+---------------+-------------+\n\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1741 Find Total Time Spent By Each Employee",
    "repo": "datix",
    "path": "1741-find-total-time-spent-by-each-employee",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect to_char(event_day,'YYYY-MM-DD') as day ,emp_id,sum(out_time) - sum(in_time) as total_time from Employees group by emp_id,event_day order by emp_id,event_day;\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/find-total-time-spent-by-each-employee\">1892. Find Total Time Spent by Each Employee</a></h2><h3>Easy</h3><hr><p>Table: <code>Employees</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| emp_id      | int  |\n| event_day   | date |\n| in_time     | int  |\n| out_time    | int  |\n+-------------+------+\n(emp_id, event_day, in_time) is the primary key (combinations of columns with unique values) of this table.\nThe table shows the employees&#39; entries and exits in an office.\nevent_day is the day at which this event happened, in_time is the minute at which the employee entered the office, and out_time is the minute at which they left the office.\nin_time and out_time are between 1 and 1440.\nIt is guaranteed that no two events on the same day intersect in time, and in_time &lt; out_time.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to calculate the total time <strong>in minutes</strong> spent by each employee on each day at the office. Note that within one day, an employee can enter and leave more than once. The time spent in the office for a single entry is <code>out_time - in_time</code>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployees table:\n+--------+------------+---------+----------+\n| emp_id | event_day  | in_time | out_time |\n+--------+------------+---------+----------+\n| 1      | 2020-11-28 | 4       | 32       |\n| 1      | 2020-11-28 | 55      | 200      |\n| 1      | 2020-12-03 | 1       | 42       |\n| 2      | 2020-11-28 | 3       | 33       |\n| 2      | 2020-12-09 | 47      | 74       |\n+--------+------------+---------+----------+\n<strong>Output:</strong> \n+------------+--------+------------+\n| day        | emp_id | total_time |\n+------------+--------+------------+\n| 2020-11-28 | 1      | 173        |\n| 2020-11-28 | 2      | 30         |\n| 2020-12-03 | 1      | 41         |\n| 2020-12-09 | 2      | 27         |\n+------------+--------+------------+\n<strong>Explanation:</strong> \nEmployee 1 has three events: two on day 2020-11-28 with a total of (32 - 4) + (200 - 55) = 173, and one on day 2020-12-03 with a total of (42 - 1) = 41.\nEmployee 2 has two events: one on day 2020-11-28 with a total of (33 - 3) = 30, and one on day 2020-12-09 with a total of (74 - 47) = 27.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1757 Recyclable And Low Fat Products",
    "repo": "datix",
    "path": "1757-recyclable-and-low-fat-products",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect product_id from Products where low_fats='Y' and recyclable='Y';",
    "description": "<h2><a href=\"https://leetcode.com/problems/recyclable-and-low-fat-products\">1908. Recyclable and Low Fat Products</a></h2><h3>Easy</h3><hr><p>Table: <code>Products</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| product_id  | int     |\n| low_fats    | enum    |\n| recyclable  | enum    |\n+-------------+---------+\nproduct_id is the primary key (column with unique values) for this table.\nlow_fats is an ENUM (category) of type (&#39;Y&#39;, &#39;N&#39;) where &#39;Y&#39; means this product is low fat and &#39;N&#39; means it is not.\nrecyclable is an ENUM (category) of types (&#39;Y&#39;, &#39;N&#39;) where &#39;Y&#39; means this product is recyclable and &#39;N&#39; means it is not.</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the ids of products that are both low fat and recyclable.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nProducts table:\n+-------------+----------+------------+\n| product_id  | low_fats | recyclable |\n+-------------+----------+------------+\n| 0           | Y        | N          |\n| 1           | Y        | Y          |\n| 2           | N        | Y          |\n| 3           | Y        | Y          |\n| 4           | N        | N          |\n+-------------+----------+------------+\n<strong>Output:</strong> \n+-------------+\n| product_id  |\n+-------------+\n| 1           |\n| 3           |\n+-------------+\n<strong>Explanation:</strong> Only products 1 and 3 are both low fat and recyclable.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1789 Primary Department For Each Employee",
    "repo": "datix",
    "path": "1789-primary-department-for-each-employee",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect employee_id,department_id from Employee where employee_id in \n(select employee_id from Employee group by employee_id having count(*) = 1)\nunion \nselect employee_id,department_id from Employee where primary_flag='Y';",
    "description": "<h2><a href=\"https://leetcode.com/problems/primary-department-for-each-employee\">1942. Primary Department for Each Employee</a></h2><h3>Easy</h3><hr><p>Table: <code>Employee</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   |  Type   |\n+---------------+---------+\n| employee_id   | int     |\n| department_id | int     |\n| primary_flag  | varchar |\n+---------------+---------+\n(employee_id, department_id) is the primary key (combination of columns with unique values) for this table.\nemployee_id is the id of the employee.\ndepartment_id is the id of the department to which the employee belongs.\nprimary_flag is an ENUM (category) of type (&#39;Y&#39;, &#39;N&#39;). If the flag is &#39;Y&#39;, the department is the primary department for the employee. If the flag is &#39;N&#39;, the department is not the primary.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Employees can belong to multiple departments. When the employee joins other departments, they need to decide which department is their primary department. Note that when an employee belongs to only one department, their primary column is <code>&#39;N&#39;</code>.</p>\n\n<p>Write a solution to report all the employees with their primary department. For employees who belong to one department, report their only department.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployee table:\n+-------------+---------------+--------------+\n| employee_id | department_id | primary_flag |\n+-------------+---------------+--------------+\n| 1           | 1             | N            |\n| 2           | 1             | Y            |\n| 2           | 2             | N            |\n| 3           | 3             | N            |\n| 4           | 2             | N            |\n| 4           | 3             | Y            |\n| 4           | 4             | N            |\n+-------------+---------------+--------------+\n<strong>Output:</strong> \n+-------------+---------------+\n| employee_id | department_id |\n+-------------+---------------+\n| 1           | 1             |\n| 2           | 1             |\n| 3           | 3             |\n| 4           | 3             |\n+-------------+---------------+\n<strong>Explanation:</strong> \n- The Primary department for employee 1 is 1.\n- The Primary department for employee 2 is 1.\n- The Primary department for employee 3 is 3.\n- The Primary department for employee 4 is 3.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1795 Rearrange Products Table",
    "repo": "datix",
    "path": "1795-rearrange-products-table",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect * from (    select *\n    from Products\n    UNPIVOT (\n        price\n        for store in (store1 as 'store1',store2 as 'store2',store3 as 'store3')\n    )\n);\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/rearrange-products-table\">1948. Rearrange Products Table</a></h2><h3>Easy</h3><hr><p>Table: <code>Products</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| product_id  | int     |\n| store1      | int     |\n| store2      | int     |\n| store3      | int     |\n+-------------+---------+\nproduct_id is the primary key (column with unique values) for this table.\nEach row in this table indicates the product&#39;s price in 3 different stores: store1, store2, and store3.\nIf the product is not available in a store, the price will be null in that store&#39;s column.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to rearrange the <code>Products</code> table so that each row has <code>(product_id, store, price)</code>. If a product is not available in a store, do <strong>not</strong> include a row with that <code>product_id</code> and <code>store</code> combination in the result table.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nProducts table:\n+------------+--------+--------+--------+\n| product_id | store1 | store2 | store3 |\n+------------+--------+--------+--------+\n| 0          | 95     | 100    | 105    |\n| 1          | 70     | null   | 80     |\n+------------+--------+--------+--------+\n<strong>Output:</strong> \n+------------+--------+-------+\n| product_id | store  | price |\n+------------+--------+-------+\n| 0          | store1 | 95    |\n| 0          | store2 | 100   |\n| 0          | store3 | 105   |\n| 1          | store1 | 70    |\n| 1          | store3 | 80    |\n+------------+--------+-------+\n<strong>Explanation:</strong> \nProduct 0 is available in all three stores with prices 95, 100, and 105 respectively.\nProduct 1 is available in store1 with price 70 and store3 with price 80. The product is not available in store2.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1873 Calculate Special Bonus",
    "repo": "datix",
    "path": "1873-calculate-special-bonus",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect \nemployee_id,\ncase when name not like 'M%' and mod(employee_id,2) = 1 then salary else 0 end as bonus\nfrom Employees order by employee_id;\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/calculate-special-bonus\">2024. Calculate Special Bonus</a></h2><h3>Easy</h3><hr><p>Table: <code>Employees</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| employee_id | int     |\n| name        | varchar |\n| salary      | int     |\n+-------------+---------+\nemployee_id is the primary key (column with unique values) for this table.\nEach row of this table indicates the employee ID, employee name, and salary.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to calculate the bonus of each employee. The bonus of an employee is <code>100%</code> of their salary if the ID of the employee is <strong>an odd number</strong> and <strong>the employee&#39;s name does not start with the character </strong><code>&#39;M&#39;</code>. The bonus of an employee is <code>0</code> otherwise.</p>\n\n<p>Return the result table ordered by <code>employee_id</code>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployees table:\n+-------------+---------+--------+\n| employee_id | name    | salary |\n+-------------+---------+--------+\n| 2           | Meir    | 3000   |\n| 3           | Michael | 3800   |\n| 7           | Addilyn | 7400   |\n| 8           | Juan    | 6100   |\n| 9           | Kannon  | 7700   |\n+-------------+---------+--------+\n<strong>Output:</strong> \n+-------------+-------+\n| employee_id | bonus |\n+-------------+-------+\n| 2           | 0     |\n| 3           | 0     |\n| 7           | 7400  |\n| 8           | 0     |\n| 9           | 7700  |\n+-------------+-------+\n<strong>Explanation:</strong> \nThe employees with IDs 2 and 8 get 0 bonus because they have an even employee_id.\nThe employee with ID 3 gets 0 bonus because their name starts with &#39;M&#39;.\nThe rest of the employees get a 100% bonus.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1890 The Latest Login In 2020",
    "repo": "datix",
    "path": "1890-the-latest-login-in-2020",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect user_id , max(time_stamp) as last_stamp from Logins where to_char(time_stamp,'YYYY') = 2020 group by user_id;",
    "description": "<h2><a href=\"https://leetcode.com/problems/the-latest-login-in-2020\">2041. The Latest Login in 2020</a></h2><h3>Easy</h3><hr><p>Table: <code>Logins</code></p>\n\n<pre>\n+----------------+----------+\n| Column Name    | Type     |\n+----------------+----------+\n| user_id        | int      |\n| time_stamp     | datetime |\n+----------------+----------+\n(user_id, time_stamp) is the primary key (combination of columns with unique values) for this table.\nEach row contains information about the login time for the user with ID user_id.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the <strong>latest</strong> login for all users in the year <code>2020</code>. Do <strong>not</strong> include the users who did not login in <code>2020</code>.</p>\n\n<p>Return the result table <strong>in any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nLogins table:\n+---------+---------------------+\n| user_id | time_stamp          |\n+---------+---------------------+\n| 6       | 2020-06-30 15:06:07 |\n| 6       | 2021-04-21 14:06:06 |\n| 6       | 2019-03-07 00:18:15 |\n| 8       | 2020-02-01 05:10:53 |\n| 8       | 2020-12-30 00:46:50 |\n| 2       | 2020-01-16 02:49:50 |\n| 2       | 2019-08-25 07:59:08 |\n| 14      | 2019-07-14 09:00:00 |\n| 14      | 2021-01-06 11:59:59 |\n+---------+---------------------+\n<strong>Output:</strong> \n+---------+---------------------+\n| user_id | last_stamp          |\n+---------+---------------------+\n| 6       | 2020-06-30 15:06:07 |\n| 8       | 2020-12-30 00:46:50 |\n| 2       | 2020-01-16 02:49:50 |\n+---------+---------------------+\n<strong>Explanation:</strong> \nUser 6 logged into their account 3 times but only once in 2020, so we include this login in the result table.\nUser 8 logged into their account 2 times in 2020, once in February and once in December. We include only the latest one (December) in the result table.\nUser 2 logged into their account 2 times but only once in 2020, so we include this login in the result table.\nUser 14 did not login in 2020, so we do not include them in the result table.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1907 Count Salary Categories",
    "repo": "datix",
    "path": "1907-count-salary-categories",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nWITH category AS (\n    SELECT\n        'Low Salary' AS category,\n        0            AS accounts_count\n    FROM\n        dual\n    UNION\n    SELECT\n        'Average Salary' AS category,\n        0                AS accounts_count\n    FROM\n        dual\n    UNION\n    SELECT\n        'High Salary' AS category,\n        0             AS accounts_count\n    FROM\n        dual\n), data AS (\n    SELECT\n        CASE\n            WHEN income < 20000                 THEN\n                'Low Salary'\n            WHEN income BETWEEN 20000 AND 50000 THEN\n                'Average Salary'\n            ELSE\n                'High Salary'\n        END               AS category,\n        COUNT(account_id) AS accounts_count\n    FROM\n        accounts\n    GROUP BY (\n        CASE\n            WHEN income < 20000                 THEN\n                'Low Salary'\n            WHEN income BETWEEN 20000 AND 50000 THEN\n                'Average Salary'\n            ELSE\n                'High Salary'\n        END\n    )\n)\nSELECT\n    category,\n    accounts_count\nFROM\n    category\nWHERE\n    category NOT IN (\n        SELECT DISTINCT\n            category\n        FROM\n            data\n    )\nUNION\nSELECT\n    category,\n    accounts_count\nFROM\n    data\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/count-salary-categories/description/\">2057. Count Salary Categories</a></h2><h3>Medium</h3><hr><p>Table: <code>Accounts</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| account_id  | int  |\n| income      | int  |\n+-------------+------+\naccount_id is the primary key (column with unique values) for this table.\nEach row contains information about the monthly income for one bank account.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution&nbsp;to calculate the number of bank accounts for each salary category. The salary categories are:</p>\n\n<ul>\n\t<li><code>&quot;Low Salary&quot;</code>: All the salaries <strong>strictly less</strong> than <code>$20000</code>.</li>\n\t<li><code>&quot;Average Salary&quot;</code>: All the salaries in the <strong>inclusive</strong> range <code>[$20000, $50000]</code>.</li>\n\t<li><code>&quot;High Salary&quot;</code>: All the salaries <strong>strictly greater</strong> than <code>$50000</code>.</li>\n</ul>\n\n<p>The result table <strong>must</strong> contain all three categories. If there are no accounts in a category,&nbsp;return&nbsp;<code>0</code>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nAccounts table:\n+------------+--------+\n| account_id | income |\n+------------+--------+\n| 3          | 108939 |\n| 2          | 12747  |\n| 8          | 87709  |\n| 6          | 91796  |\n+------------+--------+\n<strong>Output:</strong> \n+----------------+----------------+\n| category       | accounts_count |\n+----------------+----------------+\n| Low Salary     | 1              |\n| Average Salary | 0              |\n| High Salary    | 3              |\n+----------------+----------------+\n<strong>Explanation:</strong> \nLow Salary: Account 2.\nAverage Salary: No accounts.\nHigh Salary: Accounts 3, 6, and 8.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1965 Employees With Missing Information",
    "repo": "datix",
    "path": "1965-employees-with-missing-information",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect \n    nvl(e1.employee_id,0) + nvl(s1.employee_id,0) as employee_id \nfrom Employees e1 full outer join Salaries s1 \non e1.employee_id = s1.employee_id\nwhere s1.salary is null or e1.name is null \norder by nvl(e1.employee_id,0) + nvl(s1.employee_id,0) asc;\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/employees-with-missing-information\">2110. Employees With Missing Information</a></h2><h3>Easy</h3><hr><p>Table: <code>Employees</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| employee_id | int     |\n| name        | varchar |\n+-------------+---------+\nemployee_id is the column with unique values for this table.\nEach row of this table indicates the name of the employee whose ID is employee_id.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>Salaries</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| employee_id | int     |\n| salary      | int     |\n+-------------+---------+\nemployee_id is the column with unique values for this table.\nEach row of this table indicates the salary of the employee whose ID is employee_id.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to report the IDs of all the employees with <strong>missing information</strong>. The information of an employee is missing if:</p>\n\n<ul>\n\t<li>The employee&#39;s <strong>name</strong> is missing, or</li>\n\t<li>The employee&#39;s <strong>salary</strong> is missing.</li>\n</ul>\n\n<p>Return the result table ordered by <code>employee_id</code> <strong>in ascending order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployees table:\n+-------------+----------+\n| employee_id | name     |\n+-------------+----------+\n| 2           | Crew     |\n| 4           | Haven    |\n| 5           | Kristian |\n+-------------+----------+\nSalaries table:\n+-------------+--------+\n| employee_id | salary |\n+-------------+--------+\n| 5           | 76071  |\n| 1           | 22517  |\n| 4           | 63539  |\n+-------------+--------+\n<strong>Output:</strong> \n+-------------+\n| employee_id |\n+-------------+\n| 1           |\n| 2           |\n+-------------+\n<strong>Explanation:</strong> \nEmployees 1, 2, 4, and 5 are working at this company.\nThe name of employee 1 is missing.\nThe salary of employee 2 is missing.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "1978 Employees Whose Manager Left The Company",
    "repo": "datix",
    "path": "1978-employees-whose-manager-left-the-company",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nselect employee_id from Employees where manager_id not in (\nselect employee_id  from Employees\n) and salary  < 30000 order by employee_id;",
    "description": "<h2><a href=\"https://leetcode.com/problems/employees-whose-manager-left-the-company\">2127. Employees Whose Manager Left the Company</a></h2><h3>Easy</h3><hr><p>Table: <code>Employees</code></p>\n\n<pre>\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| employee_id | int      |\n| name        | varchar  |\n| manager_id  | int      |\n| salary      | int      |\n+-------------+----------+\nIn SQL, employee_id is the primary key for this table.\nThis table contains information about the employees, their salary, and the ID of their manager. Some employees do not have a manager (manager_id is null). \n</pre>\n\n<p>&nbsp;</p>\n\n<p>Find the IDs of the employees whose salary is strictly less than <code>$30000</code> and whose manager left the company. When a manager leaves the company, their information is deleted from the <code>Employees</code> table, but the reports still have their <code>manager_id</code> set to the manager that left.</p>\n\n<p>Return the result table ordered by <code>employee_id</code>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input: </strong> \nEmployees table:\n+-------------+-----------+------------+--------+\n| employee_id | name      | manager_id | salary |\n+-------------+-----------+------------+--------+\n| 3           | Mila      | 9          | 60301  |\n| 12          | Antonella | null       | 31000  |\n| 13          | Emery     | null       | 67084  |\n| 1           | Kalel     | 11         | 21241  |\n| 9           | Mikaela   | null       | 50937  |\n| 11          | Joziah    | 6          | 28485  |\n+-------------+-----------+------------+--------+\n<strong>Output:</strong> \n+-------------+\n| employee_id |\n+-------------+\n| 11          |\n+-------------+\n\n<strong>Explanation:</strong> \nThe employees with a salary less than $30000 are 1 (Kalel) and 11 (Joziah).\nKalel&#39;s manager is employee 11, who is still in the company (Joziah).\nJoziah&#39;s manager is employee 6, who left the company because there is no row for employee 6 as it was deleted.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "2356 Number Of Unique Subjects Taught By Each Teacher",
    "repo": "datix",
    "path": "2356-number-of-unique-subjects-taught-by-each-teacher",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nselect teacher_id,count(subject_id) as cnt from (select distinct teacher_id,subject_id from Teacher ) group by teacher_id order by teacher_id",
    "description": "<h2><a href=\"https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher\">2495. Number of Unique Subjects Taught by Each Teacher</a></h2><h3>Easy</h3><hr><p>Table: <code>Teacher</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| teacher_id  | int  |\n| subject_id  | int  |\n| dept_id     | int  |\n+-------------+------+\n(subject_id, dept_id) is the primary key (combinations of columns with unique values) of this table.\nEach row in this table indicates that the teacher with teacher_id teaches the subject subject_id in the department dept_id.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to calculate&nbsp;the number of unique subjects each teacher teaches in the university.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The&nbsp;result format is shown in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nTeacher table:\n+------------+------------+---------+\n| teacher_id | subject_id | dept_id |\n+------------+------------+---------+\n| 1          | 2          | 3       |\n| 1          | 2          | 4       |\n| 1          | 3          | 3       |\n| 2          | 1          | 1       |\n| 2          | 2          | 1       |\n| 2          | 3          | 1       |\n| 2          | 4          | 1       |\n+------------+------------+---------+\n<strong>Output:</strong>  \n+------------+-----+\n| teacher_id | cnt |\n+------------+-----+\n| 1          | 2   |\n| 2          | 4   |\n+------------+-----+\n<strong>Explanation:</strong> \nTeacher 1:\n  - They teach subject 2 in departments 3 and 4.\n  - They teach subject 3 in department 3.\nTeacher 2:\n  - They teach subject 1 in department 1.\n  - They teach subject 2 in department 1.\n  - They teach subject 3 in department 1.\n  - They teach subject 4 in department 1.\n</pre>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "3436 Find Valid Emails",
    "repo": "datix",
    "path": "3436-find-valid-emails",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n/*\n\nMethod 1 \n\nSELECT user_id,\n       email\n  FROM users\n WHERE regexp_like(email, '^[A-Za-z_0-9]+@[A-Za-z]+\\.com$')\n ORDER BY user_id;\n\n*/\n\n\n-- Method 2 \nwith data as\n(\n   select user_id, email,regexp_replace(upper(email),'[^@]','') as at_email from users where regexp_replace(upper(email),'[^@]','') is not null\n) , at_check as\n(\n    select user_id , email from data where length(at_email) =1 \n), end_check as\n(\n   select user_id, email from at_check where email  like '%.com'\n) , after_before_check as\n(\n   select user_id, email,start_at_pos,substr(email,start_at_pos+1,(last_dot_pos-start_at_pos)-1) as mid_string from \n   (  \n      select user_id,email,instr(email,'@') as start_at_pos , instr(email,'.') as last_dot_pos  from end_check\n   ) where regexp_like(substr(email,start_at_pos+1,(last_dot_pos-start_at_pos)-1),'^[a-zA-z]+$')\n) , before_at as \n(\n    select user_id,email,substr(email,1,start_at_pos-1) from after_before_check where regexp_like(substr(email,1,start_at_pos-1),'^[a-zA-Z0-9_]+$')\n)\nselect user_id,email from before_at order by user_id",
    "description": "<h2><a href=\"https://leetcode.com/problems/find-valid-emails\">3782. Find Valid Emails</a></h2><h3>Easy</h3><hr><p>Table: <code>Users</code></p>\n\n<pre>\n+-----------------+---------+\n| Column Name     | Type    |\n+-----------------+---------+\n| user_id         | int     |\n| email           | varchar |\n+-----------------+---------+\n(user_id) is the unique key for this table.\nEach row contains a user&#39;s unique ID and email address.\n</pre>\n\n<p>Write a solution to find all the <strong>valid email addresses</strong>. A valid email address meets the following criteria:</p>\n\n<ul>\n\t<li>It contains exactly one <code>@</code> symbol.</li>\n\t<li>It ends with <code>.com</code>.</li>\n\t<li>The part before the <code>@</code> symbol contains only <strong>alphanumeric</strong> characters and <strong>underscores</strong>.</li>\n\t<li>The part after the <code>@</code> symbol and before <code>.com</code> contains a domain name <strong>that contains only letters</strong>.</li>\n</ul>\n\n<p>Return<em> the result table ordered by</em> <code>user_id</code> <em>in</em> <strong>ascending </strong><em>order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong></p>\n\n<p>Users table:</p>\n\n<pre class=\"example-io\">\n+---------+---------------------+\n| user_id | email               |\n+---------+---------------------+\n| 1       | alice@example.com   |\n| 2       | bob_at_example.com  |\n| 3       | charlie@example.net |\n| 4       | david@domain.com    |\n| 5       | eve@invalid         |\n+---------+---------------------+\n</pre>\n\n<p><strong>Output:</strong></p>\n\n<pre class=\"example-io\">\n+---------+-------------------+\n| user_id | email             |\n+---------+-------------------+\n| 1       | alice@example.com |\n| 4       | david@domain.com  |\n+---------+-------------------+\n</pre>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li><strong>alice@example.com</strong> is valid because it contains one <code>@</code>, alice&nbsp;is alphanumeric, and example.com&nbsp;starts with a letter and ends with .com.</li>\n\t<li><strong>bob_at_example.com</strong> is invalid because it contains an underscore instead of an <code>@</code>.</li>\n\t<li><strong>charlie@example.net</strong> is invalid because the domain does not end with <code>.com</code>.</li>\n\t<li><strong>david@domain.com</strong> is valid because it meets all criteria.</li>\n\t<li><strong>eve@invalid</strong> is invalid because the domain does not end with <code>.com</code>.</li>\n</ul>\n\n<p>Result table is ordered by user_id in ascending order.</p>\n</div>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "3465 Find Products With Valid Serial Numbers",
    "repo": "datix",
    "path": "3465-find-products-with-valid-serial-numbers",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nSELECT *\nFROM products\nWHERE REGEXP_LIKE(description, '(^|[^A-Z0-9])SN[0-9]{4}-[0-9]{4}([^0-9]|$)');\norder by product_id",
    "description": "<h2><a href=\"https://leetcode.com/problems/find-products-with-valid-serial-numbers\">3803. Find Products with Valid Serial Numbers</a></h2><h3>Easy</h3><hr><p>Table: <code>products</code></p>\n\n<pre>\n+--------------+------------+\n| Column Name  | Type       |\n+--------------+------------+\n| product_id   | int        |\n| product_name | varchar    |\n| description  | varchar    |\n+--------------+------------+\n(product_id) is the unique key for this table.\nEach row in the table represents a product with its unique ID, name, and description.\n</pre>\n\n<p>Write a solution to find all products whose description <strong>contains a valid serial number</strong> pattern. A valid serial number follows these rules:</p>\n\n<ul>\n\t<li>It starts with the letters <strong>SN</strong>&nbsp;(case-sensitive).</li>\n\t<li>Followed by exactly <code>4</code> digits.</li>\n\t<li>It must have a hyphen (-) <strong>followed by exactly</strong> <code>4</code> digits.</li>\n\t<li>The serial number must be within the description (it may not necessarily start at the beginning).</li>\n</ul>\n\n<p>Return <em>the result table&nbsp;ordered by</em> <code>product_id</code> <em>in <strong>ascending</strong> order</em>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong></p>\n\n<p>products table:</p>\n\n<pre class=\"example-io\">\n+------------+--------------+------------------------------------------------------+\n| product_id | product_name | description                                          |\n+------------+--------------+------------------------------------------------------+\n| 1          | Widget A     | This is a sample product with SN1234-5678            |\n| 2          | Widget B     | A product with serial SN9876-1234 in the description |\n| 3          | Widget C     | Product SN1234-56789 is available now                |\n| 4          | Widget D     | No serial number here                                |\n| 5          | Widget E     | Check out SN4321-8765 in this description            |\n+------------+--------------+------------------------------------------------------+\n    </pre>\n\n<p><strong>Output:</strong></p>\n\n<pre class=\"example-io\">\n+------------+--------------+------------------------------------------------------+\n| product_id | product_name | description                                          |\n+------------+--------------+------------------------------------------------------+\n| 1          | Widget A     | This is a sample product with SN1234-5678            |\n| 2          | Widget B     | A product with serial SN9876-1234 in the description |\n| 5          | Widget E     | Check out SN4321-8765 in this description            |\n+------------+--------------+------------------------------------------------------+\n    </pre>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li><strong>Product 1:</strong> Valid serial number SN1234-5678</li>\n\t<li><strong>Product 2:</strong> Valid serial number SN9876-1234</li>\n\t<li><strong>Product 3:</strong> Invalid serial number SN1234-56789 (contains 5 digits after the hyphen)</li>\n\t<li><strong>Product 4:</strong> No serial number in the description</li>\n\t<li><strong>Product 5:</strong> Valid serial number SN4321-8765</li>\n</ul>\n\n<p>The result table is ordered by product_id in ascending order.</p>\n</div>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "3570 Find Books With No Available Copies",
    "repo": "datix",
    "path": "3570-find-books-with-no-available-copies",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nWITH not_return AS (\n    SELECT\n        book_id,\n        SUM(COUNT(*))\n        OVER(PARTITION BY book_id) AS current_borrowers\n    FROM\n        borrowing_records\n    WHERE\n        return_date IS NULL\n    GROUP BY\n        book_id\n    ORDER BY\n        book_id\n)\nSELECT\n    l.book_id,\n    l.title,\n    l.author,\n    l.genre,\n    l.publication_year,\n    n.current_borrowers\nFROM\n         library_books l\n    JOIN not_return n ON l.book_id = n.book_id\n                         AND l.total_copies = n.current_borrowers\nORDER BY\n    n.current_borrowers DESC,\n    l.title ASC;",
    "description": "<h2><a href=\"https://leetcode.com/problems/find-books-with-no-available-copies\">3910. Find Books with No Available Copies</a></h2><h3>Easy</h3><hr><p>Table: <code>library_books</code></p>\n\n<pre>\n+------------------+---------+\n| Column Name      | Type    |\n+------------------+---------+\n| book_id          | int     |\n| title            | varchar |\n| author           | varchar |\n| genre            | varchar |\n| publication_year | int     |\n| total_copies     | int     |\n+------------------+---------+\nbook_id is the unique identifier for this table.\nEach row contains information about a book in the library, including the total number of copies owned by the library.\n</pre>\n\n<p>Table: <code>borrowing_records</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| record_id     | int     |\n| book_id       | int     |\n| borrower_name | varchar |\n| borrow_date   | date    |\n| return_date   | date    |\n+---------------+---------+\nrecord_id is the unique identifier for this table.\nEach row represents a borrowing transaction and return_date is NULL if the book is currently borrowed and hasn&#39;t been returned yet.\n</pre>\n\n<p>Write a solution to find <strong>all books</strong> that are <strong>currently borrowed (not returned)</strong> and have <strong>zero copies available</strong> in the library.</p>\n\n<ul>\n\t<li>A book is considered <strong>currently borrowed</strong> if there exists a<strong> </strong>borrowing record with a <strong>NULL</strong> <code>return_date</code></li>\n</ul>\n\n<p>Return <em>the result table ordered by current borrowers in <strong>descending</strong> order, then by book title in <strong>ascending</strong> order.</em></p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong></p>\n\n<p>library_books table:</p>\n\n<pre class=\"example-io\">\n+---------+------------------------+------------------+----------+------------------+--------------+\n| book_id | title                  | author           | genre    | publication_year | total_copies |\n+---------+------------------------+------------------+----------+------------------+--------------+\n| 1       | The Great Gatsby       | F. Scott         | Fiction  | 1925             | 3            |\n| 2       | To Kill a Mockingbird  | Harper Lee       | Fiction  | 1960             | 3            |\n| 3       | 1984                   | George Orwell    | Dystopian| 1949             | 1            |\n| 4       | Pride and Prejudice    | Jane Austen      | Romance  | 1813             | 2            |\n| 5       | The Catcher in the Rye | J.D. Salinger    | Fiction  | 1951             | 1            |\n| 6       | Brave New World        | Aldous Huxley    | Dystopian| 1932             | 4            |\n+---------+------------------------+------------------+----------+------------------+--------------+\n</pre>\n\n<p>borrowing_records table:</p>\n\n<pre class=\"example-io\">\n+-----------+---------+---------------+-------------+-------------+\n| record_id | book_id | borrower_name | borrow_date | return_date |\n+-----------+---------+---------------+-------------+-------------+\n| 1         | 1       | Alice Smith   | 2024-01-15  | NULL        |\n| 2         | 1       | Bob Johnson   | 2024-01-20  | NULL        |\n| 3         | 2       | Carol White   | 2024-01-10  | 2024-01-25  |\n| 4         | 3       | David Brown   | 2024-02-01  | NULL        |\n| 5         | 4       | Emma Wilson   | 2024-01-05  | NULL        |\n| 6         | 5       | Frank Davis   | 2024-01-18  | 2024-02-10  |\n| 7         | 1       | Grace Miller  | 2024-02-05  | NULL        |\n| 8         | 6       | Henry Taylor  | 2024-01-12  | NULL        |\n| 9         | 2       | Ivan Clark    | 2024-02-12  | NULL        |\n| 10        | 2       | Jane Adams    | 2024-02-15  | NULL        |\n+-----------+---------+---------------+-------------+-------------+\n</pre>\n\n<p><strong>Output:</strong></p>\n\n<pre class=\"example-io\">\n+---------+------------------+---------------+-----------+------------------+-------------------+\n| book_id | title            | author        | genre     | publication_year | current_borrowers |\n+---------+------------------+---------------+-----------+------------------+-------------------+\n| 1       | The Great Gatsby | F. Scott      | Fiction   | 1925             | 3                 | \n| 3       | 1984             | George Orwell | Dystopian | 1949             | 1                 |\n+---------+------------------+---------------+-----------+------------------+-------------------+\n</pre>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li><strong>The Great Gatsby (book_id = 1):</strong>\n\n\t<ul>\n\t\t<li>Total copies: 3</li>\n\t\t<li>Currently borrowed by Alice Smith, Bob Johnson, and Grace Miller (3 borrowers)</li>\n\t\t<li>Available copies: 3 - 3 = 0</li>\n\t\t<li>Included because available_copies = 0</li>\n\t</ul>\n\t</li>\n\t<li><strong>1984 (book_id = 3):</strong>\n\t<ul>\n\t\t<li>Total copies: 1</li>\n\t\t<li>Currently borrowed by David Brown (1 borrower)</li>\n\t\t<li>Available copies: 1 - 1 = 0</li>\n\t\t<li>Included because available_copies = 0</li>\n\t</ul>\n\t</li>\n\t<li><strong>Books not included:</strong>\n\t<ul>\n\t\t<li>To Kill a Mockingbird (book_id = 2): Total copies = 3, current borrowers = 2, available = 1</li>\n\t\t<li>Pride and Prejudice (book_id = 4): Total copies = 2, current borrowers = 1, available = 1</li>\n\t\t<li>The Catcher in the Rye (book_id = 5): Total copies = 1, current borrowers = 0, available = 1</li>\n\t\t<li>Brave New World (book_id = 6): Total copies = 4, current borrowers = 1, available = 3</li>\n\t</ul>\n\t</li>\n\t<li><strong>Result ordering:</strong>\n\t<ul>\n\t\t<li>The Great Gatsby appears first with 3 current borrowers</li>\n\t\t<li>1984 appears second with 1 current borrower</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Output table is ordered by current_borrowers in descending order, then by book_title in ascending order.</p>\n</div>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "3611 Find Overbooked Employees",
    "repo": "datix",
    "path": "3611-find-overbooked-employees",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nWITH weekly_meetings AS (\n    /* Step 1: Calculate total meeting hours per employee per week (MonSun) */\n    SELECT\n        m.employee_id,\n        TRUNC(m.meeting_date, 'IW') AS week_start_date,\n        SUM(m.duration_hours) AS weekly_meeting_hours\n    FROM meetings m\n    GROUP BY\n        m.employee_id,\n        TRUNC(m.meeting_date, 'IW')\n),\nheavy_weeks AS (\n    /* Step 2: Keep only weeks where meeting hours > 20 (50% of 40 hours) */\n    SELECT\n        employee_id,\n        week_start_date\n    FROM weekly_meetings\n    WHERE weekly_meeting_hours > 20\n),\nheavy_week_counts AS (\n    /* Step 3: Count how many heavy weeks each employee has */\n    SELECT\n        employee_id,\n        COUNT(*) AS meeting_heavy_weeks\n    FROM heavy_weeks\n    GROUP BY employee_id\n    HAVING COUNT(*) >= 2\n)\nSELECT\n    e.employee_id,\n    e.employee_name,\n    e.department,\n    h.meeting_heavy_weeks\nFROM heavy_week_counts h\nJOIN employees e\n    ON e.employee_id = h.employee_id\nORDER BY\n    h.meeting_heavy_weeks DESC,\n    e.employee_name ASC;\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/find-overbooked-employees\">3943. Find Overbooked Employees</a></h2><h3>Medium</h3><hr><p>Table: <code>employees</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| employee_id   | int     |\n| employee_name | varchar |\n| department    | varchar |\n+---------------+---------+\nemployee_id is the unique identifier for this table.\nEach row contains information about an employee and their department.\n</pre>\n\n<p>Table: <code>meetings</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| meeting_id    | int     |\n| employee_id   | int     |\n| meeting_date  | date    |\n| meeting_type  | varchar |\n| duration_hours| decimal |\n+---------------+---------+\nmeeting_id is the unique identifier for this table.\nEach row represents a meeting attended by an employee. meeting_type can be &#39;Team&#39;, &#39;Client&#39;, or &#39;Training&#39;.\n</pre>\n\n<p>Write a solution to find employees who are <strong>meeting-heavy</strong> - employees who spend more than <code>50%</code> of their working time in meetings during any given week.</p>\n\n<ul>\n\t<li>Assume a standard work week is <code>40</code><strong> hours</strong></li>\n\t<li>Calculate <strong>total meeting hours</strong> per employee <strong>per week</strong> (<strong>Monday to Sunday</strong>)</li>\n\t<li>An employee is meeting-heavy if their weekly meeting hours <code>&gt;</code> <code>20</code> hours (<code>50%</code> of <code>40</code> hours)</li>\n\t<li>Count how many weeks each employee was meeting-heavy</li>\n\t<li><strong>Only include</strong> employees who were meeting-heavy for <strong>at least </strong><code>2</code><strong> weeks</strong></li>\n</ul>\n\n<p>Return <em>the result table ordered by the number of meeting-heavy weeks in <strong>descending</strong> order, then by employee name in <strong>ascending</strong> order</em>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong></p>\n\n<p>employees table:</p>\n\n<pre class=\"example-io\">\n+-------------+----------------+-------------+\n| employee_id | employee_name  | department  |\n+-------------+----------------+-------------+\n| 1           | Alice Johnson  | Engineering |\n| 2           | Bob Smith      | Marketing   |\n| 3           | Carol Davis    | Sales       |\n| 4           | David Wilson   | Engineering |\n| 5           | Emma Brown     | HR          |\n+-------------+----------------+-------------+\n</pre>\n\n<p>meetings table:</p>\n\n<pre class=\"example-io\">\n+------------+-------------+--------------+--------------+----------------+\n| meeting_id | employee_id | meeting_date | meeting_type | duration_hours |\n+------------+-------------+--------------+--------------+----------------+\n| 1          | 1           | 2023-06-05   | Team         | 8.0            |\n| 2          | 1           | 2023-06-06   | Client       | 6.0            |\n| 3          | 1           | 2023-06-07   | Training     | 7.0            |\n| 4          | 1           | 2023-06-12   | Team         | 12.0           |\n| 5          | 1           | 2023-06-13   | Client       | 9.0            |\n| 6          | 2           | 2023-06-05   | Team         | 15.0           |\n| 7          | 2           | 2023-06-06   | Client       | 8.0            |\n| 8          | 2           | 2023-06-12   | Training     | 10.0           |\n| 9          | 3           | 2023-06-05   | Team         | 4.0            |\n| 10         | 3           | 2023-06-06   | Client       | 3.0            |\n| 11         | 4           | 2023-06-05   | Team         | 25.0           |\n| 12         | 4           | 2023-06-19   | Client       | 22.0           |\n| 13         | 5           | 2023-06-05   | Training     | 2.0            |\n+------------+-------------+--------------+--------------+----------------+\n</pre>\n\n<p><strong>Output:</strong></p>\n\n<pre class=\"example-io\">\n+-------------+----------------+-------------+---------------------+\n| employee_id | employee_name  | department  | meeting_heavy_weeks |\n+-------------+----------------+-------------+---------------------+\n| 1           | Alice Johnson  | Engineering | 2                   |\n| 4           | David Wilson   | Engineering | 2                   |\n+-------------+----------------+-------------+---------------------+\n</pre>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li><strong>Alice Johnson (employee_id = 1):</strong>\n\n\t<ul>\n\t\t<li>Week of June 5-11 (2023-06-05 to 2023-06-11): 8.0 + 6.0 + 7.0 = 21.0 hours (&gt; 20 hours)</li>\n\t\t<li>Week of June 12-18 (2023-06-12 to 2023-06-18): 12.0 + 9.0 = 21.0 hours (&gt; 20 hours)</li>\n\t\t<li>Meeting-heavy for 2 weeks</li>\n\t</ul>\n\t</li>\n\t<li><strong>David Wilson (employee_id = 4):</strong>\n\t<ul>\n\t\t<li>Week of June 5-11: 25.0 hours (&gt; 20 hours)</li>\n\t\t<li>Week of June 19-25: 22.0 hours (&gt; 20 hours)</li>\n\t\t<li>Meeting-heavy for 2 weeks</li>\n\t</ul>\n\t</li>\n\t<li><strong>Employees not included:</strong>\n\t<ul>\n\t\t<li>Bob Smith (employee_id = 2): Week of June 5-11: 15.0 + 8.0 = 23.0 hours (&gt; 20), Week of June 12-18: 10.0 hours (&lt; 20). Only 1 meeting-heavy week</li>\n\t\t<li>Carol Davis (employee_id = 3): Week of June 5-11: 4.0 + 3.0 = 7.0 hours (&lt; 20). No meeting-heavy weeks</li>\n\t\t<li>Emma Brown (employee_id = 5): Week of June 5-11: 2.0 hours (&lt; 20). No meeting-heavy weeks</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>The result table is ordered by meeting_heavy_weeks in descending order, then by employee name in ascending order.</p>\n</div>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "3626 Find Stores With Inventory Imbalance",
    "repo": "datix",
    "path": "3626-find-stores-with-inventory-imbalance",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nWITH product_cnt AS (\n    SELECT store_id\n    FROM inventory\n    GROUP BY store_id\n    HAVING COUNT(DISTINCT product_name) >= 3\n),\nranked AS (\n    SELECT\n        i.store_id,\n        i.product_name,\n        i.quantity,\n        i.price,\n        ROW_NUMBER() OVER (PARTITION BY i.store_id ORDER BY i.price DESC) AS rn_exp,\n        ROW_NUMBER() OVER (PARTITION BY i.store_id ORDER BY i.price ASC)  AS rn_cheap\n    FROM inventory i JOIN product_cnt p ON i.store_id = p.store_id\n),\nexpensive AS (\n    SELECT store_id, product_name, quantity\n    FROM ranked\n    WHERE rn_exp = 1\n),\ncheapest AS (\n    SELECT store_id, product_name, quantity\n    FROM ranked\n    WHERE rn_cheap = 1\n)\nSELECT\n    s.store_id,\n    s.store_name,\n    s.location,\n    e.product_name AS most_exp_product,\n    c.product_name AS cheapest_product,\n    ROUND(c.quantity / e.quantity, 2) AS imbalance_ratio\nFROM expensive e\nJOIN cheapest c\n  ON e.store_id = c.store_id\nJOIN stores s\n  ON s.store_id = e.store_id\nWHERE e.quantity < c.quantity\nORDER BY imbalance_ratio DESC, s.store_name ASC;",
    "description": "<h2><a href=\"https://leetcode.com/problems/find-stores-with-inventory-imbalance\">3971. Find Stores with Inventory Imbalance</a></h2><h3>Medium</h3><hr><p>Table: <code>stores</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| store_id    | int     |\n| store_name  | varchar |\n| location    | varchar |\n+-------------+---------+\nstore_id is the unique identifier for this table.\nEach row contains information about a store and its location.\n</pre>\n\n<p>Table: <code>inventory</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| inventory_id| int     |\n| store_id    | int     |\n| product_name| varchar |\n| quantity    | int     |\n| price       | decimal |\n+-------------+---------+\ninventory_id is the unique identifier for this table.\nEach row represents the inventory of a specific product at a specific store.\n</pre>\n\n<p>Write a solution to find stores that have <strong>inventory imbalance</strong> - stores where the most expensive product has lower stock than the cheapest product.</p>\n\n<ul>\n\t<li>For each store, identify the <strong>most expensive product</strong> (highest price) and its quantity</li>\n\t<li>For each store, identify the <strong>cheapest product</strong> (lowest price) and its quantity</li>\n\t<li>A store has inventory imbalance if the most expensive product&#39;s quantity is <strong>less than</strong> the cheapest product&#39;s quantity</li>\n\t<li>Calculate the <strong>imbalance ratio</strong> as (cheapest_quantity / most_expensive_quantity)</li>\n\t<li><strong>Round</strong> the imbalance ratio to <strong>2</strong> decimal places</li>\n\t<li>Only include stores that have <strong>at least </strong><code>3</code><strong> different products</strong></li>\n</ul>\n\n<p>Return <em>the result table ordered by imbalance ratio in <strong>descending</strong> order, then by store name in <strong>ascending</strong> order</em>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong></p>\n\n<p>stores table:</p>\n\n<pre class=\"example-io\">\n+----------+----------------+-------------+\n| store_id | store_name     | location    |\n+----------+----------------+-------------+\n| 1        | Downtown Tech  | New York    |\n| 2        | Suburb Mall    | Chicago     |\n| 3        | City Center    | Los Angeles |\n| 4        | Corner Shop    | Miami       |\n| 5        | Plaza Store    | Seattle     |\n+----------+----------------+-------------+\n</pre>\n\n<p>inventory table:</p>\n\n<pre class=\"example-io\">\n+--------------+----------+--------------+----------+--------+\n| inventory_id | store_id | product_name | quantity | price  |\n+--------------+----------+--------------+----------+--------+\n| 1            | 1        | Laptop       | 5        | 999.99 |\n| 2            | 1        | Mouse        | 50       | 19.99  |\n| 3            | 1        | Keyboard     | 25       | 79.99  |\n| 4            | 1        | Monitor      | 15       | 299.99 |\n| 5            | 2        | Phone        | 3        | 699.99 |\n| 6            | 2        | Charger      | 100      | 25.99  |\n| 7            | 2        | Case         | 75       | 15.99  |\n| 8            | 2        | Headphones   | 20       | 149.99 |\n| 9            | 3        | Tablet       | 2        | 499.99 |\n| 10           | 3        | Stylus       | 80       | 29.99  |\n| 11           | 3        | Cover        | 60       | 39.99  |\n| 12           | 4        | Watch        | 10       | 299.99 |\n| 13           | 4        | Band         | 25       | 49.99  |\n| 14           | 5        | Camera       | 8        | 599.99 |\n| 15           | 5        | Lens         | 12       | 199.99 |\n+--------------+----------+--------------+----------+--------+\n</pre>\n\n<p><strong>Output:</strong></p>\n\n<pre class=\"example-io\">\n+----------+----------------+-------------+------------------+--------------------+------------------+\n| store_id | store_name     | location    | most_exp_product | cheapest_product   | imbalance_ratio  |\n+----------+----------------+-------------+------------------+--------------------+------------------+\n| 3        | City Center    | Los Angeles | Tablet           | Stylus             | 40.00            |\n| 1        | Downtown Tech  | New York    | Laptop           | Mouse              | 10.00            |\n| 2        | Suburb Mall    | Chicago     | Phone            | Case               | 25.00            |\n+----------+----------------+-------------+------------------+--------------------+------------------+\n</pre>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li><strong>Downtown Tech (store_id = 1):</strong>\n\n\t<ul>\n\t\t<li>Most expensive product: Laptop ($999.99) with quantity 5</li>\n\t\t<li>Cheapest product: Mouse ($19.99) with quantity 50</li>\n\t\t<li>Inventory imbalance: 5 &lt; 50 (expensive product has lower stock)</li>\n\t\t<li>Imbalance ratio: 50 / 5 = 10.00</li>\n\t\t<li>Has 4 products (&ge; 3), so qualifies</li>\n\t</ul>\n\t</li>\n\t<li><strong>Suburb Mall (store_id = 2):</strong>\n\t<ul>\n\t\t<li>Most expensive product: Phone ($699.99) with quantity 3</li>\n\t\t<li>Cheapest product: Case ($15.99) with quantity 75</li>\n\t\t<li>Inventory imbalance: 3 &lt; 75 (expensive product has lower stock)</li>\n\t\t<li>Imbalance ratio: 75 / 3 = 25.00</li>\n\t\t<li>Has 4 products (&ge; 3), so qualifies</li>\n\t</ul>\n\t</li>\n\t<li><strong>City Center (store_id = 3):</strong>\n\t<ul>\n\t\t<li>Most expensive product: Tablet ($499.99) with quantity 2</li>\n\t\t<li>Cheapest product: Stylus ($29.99) with quantity 80</li>\n\t\t<li>Inventory imbalance: 2 &lt; 80 (expensive product has lower stock)</li>\n\t\t<li>Imbalance ratio: 80 / 2 = 40.00</li>\n\t\t<li>Has 3 products (&ge; 3), so qualifies</li>\n\t</ul>\n\t</li>\n\t<li><strong>Stores not included:</strong>\n\t<ul>\n\t\t<li>Corner Shop (store_id = 4): Only has 2 products (Watch, Band) - doesn&#39;t meet minimum 3 products requirement</li>\n\t\t<li>Plaza Store (store_id = 5): Only has 2 products (Camera, Lens) - doesn&#39;t meet minimum 3 products requirement</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>The Results table is ordered by imbalance ratio in descending order, then by store name in ascending order</p>\n</div>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "3642 Find Books With Polarized Opinions",
    "repo": "datix",
    "path": "3642-find-books-with-polarized-opinions",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n/*\n\n STEP 1: eligible_books CTE executes first\nInput: books (5 rows) + reading_sessions (20 rows)\nJOIN  GROUP BY book_id  HAVING COUNT(*) >= 5\nOutput: 3 rows (Books 1,2,3)\n Book 1: \"The Great Gatsby\" \n Book 2: \"To Kill a Mockingbird\"   \n Book 3: \"1984\" \n     Books 4,5 eliminated (<5 sessions)\n\n STEP 2: book_stats CTE executes second  \nInput: eligible_books (3 rows) + reading_sessions (16 rows for books 1,2,3)\nJOIN  GROUP BY book_id  Calculate metrics\nOutput: 3 rows with metrics:\n Book 1: total=5, max=5, min=1, extreme=5\n Book 2: total=5, max=5, min=4, extreme=5  \n Book 3: total=6, max=5, min=1, extreme=6\n\n STEP 3: Final SELECT executes last\nInput: book_stats (3 rows)\nWHERE filters:\n Book 1: 5>=4 , 1<=2 , 5/5=1.0>=0.6   KEEP\n Book 2: 5>=4 , 4<=2   ELIMINATE  \n Book 3: 5>=4 , 1<=2 , 6/6=1.0>=0.6   KEEP\nORDER BY: polarization_score DESC, TITLE DESC\nFinal Output: 2 rows (Books 1,3) \n\n\n*/\n\n-- Method 1 \n\nWITH \n-- STEP 1: Filter books with 5+ sessions\neligible_books AS (\n    SELECT b.BOOK_ID, b.TITLE, b.AUTHOR, b.GENRE, b.PAGES\n    FROM books b\n    JOIN reading_sessions rs ON b.BOOK_ID = rs.BOOK_ID\n    GROUP BY b.BOOK_ID, b.TITLE, b.AUTHOR, b.GENRE, b.PAGES\n    HAVING COUNT(*) >= 5\n),\n\n-- STEP 2: Calculate all metrics per book\nbook_stats AS (\n    SELECT \n        eb.BOOK_ID, eb.TITLE, eb.AUTHOR, eb.GENRE, eb.PAGES,\n        COUNT(*) AS total_sessions,\n        MAX(rs.session_rating) AS max_rating,\n        MIN(rs.session_rating) AS min_rating,\n        COUNT(CASE WHEN rs.session_rating <=2 OR rs.session_rating >=4 THEN 1 END) AS extreme_count\n    FROM eligible_books eb\n    JOIN reading_sessions rs ON eb.BOOK_ID = rs.BOOK_ID\n    GROUP BY eb.BOOK_ID, eb.TITLE, eb.AUTHOR, eb.GENRE, eb.PAGES\n)\n\n-- STEP 3: Apply final filters\nSELECT \n    BOOK_ID, TITLE, AUTHOR, GENRE, PAGES,\n    (max_rating - min_rating) AS rating_spread,\n    ROUND(extreme_count * 1.0 / total_sessions, 2) AS polarization_score\nFROM book_stats\nWHERE max_rating >= 4 \n  AND min_rating <= 2 \n  AND extreme_count * 1.0 / total_sessions >= 0.6\nORDER BY polarization_score DESC, TITLE DESC;\n\n\n-- Method 2 \n\nWITH data AS (\n    SELECT \n        books.BOOK_ID,\n        books.TITLE,\n        books.AUTHOR,\n        books.GENRE,\n        books.PAGES,\n        reading_sessions.session_rating,\n        COUNT(*) OVER(PARTITION BY books.BOOK_ID) AS total_session_count\n    FROM books \n    JOIN reading_sessions ON books.BOOK_ID = reading_sessions.BOOK_ID\n    WHERE books.BOOK_ID IN (\n        SELECT rs.book_id \n        FROM reading_sessions rs \n        GROUP BY rs.book_id \n        HAVING COUNT(*) >= 5\n    )\n),\nextreme_stats AS (\n    SELECT \n        BOOK_ID, TITLE, AUTHOR, GENRE, PAGES, total_session_count,\n        COUNT(*) AS extreme_count,\n        MAX(session_rating) AS max_rating,\n        MIN(session_rating) AS min_rating\n    FROM data \n    WHERE session_rating <= 2 OR session_rating >= 4\n    GROUP BY BOOK_ID, TITLE, AUTHOR, GENRE, PAGES, total_session_count\n    HAVING MAX(session_rating) >= 4 AND MIN(session_rating) <= 2\n)\nSELECT \n    BOOK_ID, TITLE, AUTHOR, GENRE, PAGES,\n    (max_rating - min_rating) AS rating_spread,\n    ROUND(extreme_count * 1.0 / total_session_count, 2) AS polarization_score\nFROM extreme_stats \nWHERE extreme_count * 1.0 / total_session_count >= 0.6\nORDER BY polarization_score DESC, TITLE DESC;\n\n\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/find-books-with-polarized-opinions\">3996. Find Books with Polarized Opinions</a></h2><h3>Easy</h3><hr><p>Table: <code>books</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| book_id     | int     |\n| title       | varchar |\n| author      | varchar |\n| genre       | varchar |\n| pages       | int     |\n+-------------+---------+\nbook_id is the unique ID for this table.\nEach row contains information about a book including its genre and page count.\n</pre>\n\n<p>Table: <code>reading_sessions</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| session_id     | int     |\n| book_id        | int     |\n| reader_name    | varchar |\n| pages_read     | int     |\n| session_rating | int     |\n+----------------+---------+\nsession_id is the unique ID for this table.\nEach row represents a reading session where someone read a portion of a book. session_rating is on a scale of 1-5.\n</pre>\n\n<p>Write a solution to find books that have <strong>polarized opinions</strong> - books that receive both very high ratings and very low ratings from different readers.</p>\n\n<ul>\n\t<li>A book has polarized opinions if it has <code>at least one rating &ge; 4</code> and <code>at least one rating &le; 2</code></li>\n\t<li>Only consider books that have <strong>at least </strong><code>5</code><strong> reading sessions</strong></li>\n\t<li>Calculate the <strong>rating spread</strong> as (<code>highest_rating - lowest_rating</code>)</li>\n\t<li>Calculate the <strong>polarization score</strong> as the number of extreme ratings (<code>ratings &le; 2 or &ge; 4</code>) divided by total sessions</li>\n\t<li><strong>Only include</strong> books where <code>polarization score &ge; 0.6</code> (at least <code>60%</code> extreme ratings)</li>\n</ul>\n\n<p>Return <em>the result table ordered by polarization score in <strong>descending</strong> order, then by title in <strong>descending</strong> order</em>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong></p>\n\n<p>books table:</p>\n\n<pre class=\"example-io\">\n+---------+------------------------+---------------+----------+-------+\n| book_id | title                  | author        | genre    | pages |\n+---------+------------------------+---------------+----------+-------+\n| 1       | The Great Gatsby       | F. Scott      | Fiction  | 180   |\n| 2       | To Kill a Mockingbird  | Harper Lee    | Fiction  | 281   |\n| 3       | 1984                   | George Orwell | Dystopian| 328   |\n| 4       | Pride and Prejudice    | Jane Austen   | Romance  | 432   |\n| 5       | The Catcher in the Rye | J.D. Salinger | Fiction  | 277   |\n+---------+------------------------+---------------+----------+-------+\n</pre>\n\n<p>reading_sessions table:</p>\n\n<pre class=\"example-io\">\n+------------+---------+-------------+------------+----------------+\n| session_id | book_id | reader_name | pages_read | session_rating |\n+------------+---------+-------------+------------+----------------+\n| 1          | 1       | Alice       | 50         | 5              |\n| 2          | 1       | Bob         | 60         | 1              |\n| 3          | 1       | Carol       | 40         | 4              |\n| 4          | 1       | David       | 30         | 2              |\n| 5          | 1       | Emma        | 45         | 5              |\n| 6          | 2       | Frank       | 80         | 4              |\n| 7          | 2       | Grace       | 70         | 4              |\n| 8          | 2       | Henry       | 90         | 5              |\n| 9          | 2       | Ivy         | 60         | 4              |\n| 10         | 2       | Jack        | 75         | 4              |\n| 11         | 3       | Kate        | 100        | 2              |\n| 12         | 3       | Liam        | 120        | 1              |\n| 13         | 3       | Mia         | 80         | 2              |\n| 14         | 3       | Noah        | 90         | 1              |\n| 15         | 3       | Olivia      | 110        | 4              |\n| 16         | 3       | Paul        | 95         | 5              |\n| 17         | 4       | Quinn       | 150        | 3              |\n| 18         | 4       | Ruby        | 140        | 3              |\n| 19         | 5       | Sam         | 80         | 1              |\n| 20         | 5       | Tara        | 70         | 2              |\n+------------+---------+-------------+------------+----------------+\n</pre>\n\n<p><strong>Output:</strong></p>\n\n<pre class=\"example-io\">\n+---------+------------------+---------------+-----------+-------+---------------+--------------------+\n| book_id | title            | author        | genre     | pages | rating_spread | polarization_score |\n+---------+------------------+---------------+-----------+-------+---------------+--------------------+\n| 1       | The Great Gatsby | F. Scott      | Fiction   | 180   | 4             | 1.00               |\n| 3       | 1984             | George Orwell | Dystopian | 328   | 4             | 1.00               |\n+---------+------------------+---------------+-----------+-------+---------------+--------------------+\n</pre>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li><strong>The Great Gatsby (book_id = 1):</strong>\n\n\t<ul>\n\t\t<li>Has 5 reading sessions (meets minimum requirement)</li>\n\t\t<li>Ratings: 5, 1, 4, 2, 5</li>\n\t\t<li>Has ratings &ge; 4: 5, 4, 5 (3 sessions)</li>\n\t\t<li>Has ratings &le; 2: 1, 2 (2 sessions)</li>\n\t\t<li>Rating spread: 5 - 1 = 4</li>\n\t\t<li>Extreme ratings (&le;2 or &ge;4): All 5 sessions (5, 1, 4, 2, 5)</li>\n\t\t<li>Polarization score: 5/5 = 1.00 (&ge; 0.6, qualifies)</li>\n\t</ul>\n\t</li>\n\t<li><strong>1984 (book_id = 3):</strong>\n\t<ul>\n\t\t<li>Has 6 reading sessions (meets minimum requirement)</li>\n\t\t<li>Ratings: 2, 1, 2, 1, 4, 5</li>\n\t\t<li>Has ratings &ge; 4: 4, 5 (2 sessions)</li>\n\t\t<li>Has ratings &le; 2: 2, 1, 2, 1 (4 sessions)</li>\n\t\t<li>Rating spread: 5 - 1 = 4</li>\n\t\t<li>Extreme ratings (&le;2 or &ge;4): All 6 sessions (2, 1, 2, 1, 4, 5)</li>\n\t\t<li>Polarization score: 6/6 = 1.00 (&ge; 0.6, qualifies)</li>\n\t</ul>\n\t</li>\n\t<li><strong>Books not included:</strong>\n\t<ul>\n\t\t<li>To Kill a Mockingbird (book_id = 2): All ratings are 4-5, no low ratings (&le;2)</li>\n\t\t<li>Pride and Prejudice (book_id = 4): Only 2 sessions (&lt; 5 minimum)</li>\n\t\t<li>The Catcher in the Rye (book_id = 5): Only 2 sessions (&lt; 5 minimum)</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>The result table is ordered by polarization score in descending order, then by book title in descending order.</p>\n</div>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "3657 Find Loyal Customers",
    "repo": "datix",
    "path": "3657-find-loyal-customers",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nWITH get_refund_details AS\n(\n    SELECT\n        customer_id AS ref_custid,\n        COUNT(*) AS refund_count\n    FROM customer_transactions\n    WHERE transaction_type = 'refund'\n    GROUP BY customer_id\n),get_purchase_details AS\n(\n    SELECT\n        customer_id AS pur_custid,\n        COUNT(*) AS purchase_count\n    FROM customer_transactions\n    WHERE transaction_type = 'purchase'\n    GROUP BY customer_id\n),get_overall_details AS\n(\n    SELECT\n        p.pur_custid,\n        p.purchase_count,\n        NVL(r.refund_count, 0) AS refund_count,\n        (p.purchase_count + NVL(r.refund_count, 0)) AS total_txn\n    FROM get_purchase_details p\n    LEFT JOIN get_refund_details r\n           ON p.pur_custid = r.ref_custid\n),cal_refund_rate AS\n(\n    SELECT\n        pur_custid,\n        purchase_count,\n        refund_count,\n        (refund_count * 1.0 / total_txn) AS refund_rate\n    FROM get_overall_details\n    WHERE purchase_count >= 3               \n      AND (refund_count * 1.0 / total_txn) < 0.20   \n),get_user_active_30_days AS\n(\n    SELECT customer_id\n    FROM (\n        SELECT\n            customer_id,\n            MAX(transaction_date) - MIN(transaction_date) AS active_days\n        FROM customer_transactions\n        GROUP BY customer_id\n    )\n    WHERE active_days >= 30                   \n)\nSELECT pur_custid AS customer_id\nFROM cal_refund_rate\nWHERE pur_custid IN (\n    SELECT customer_id FROM get_user_active_30_days\n) ORDER BY pur_custid;\n",
    "description": "<h2>Table: customer_transactions</h2>\n\n<table>\n  <tr>\n    <th>Column Name</th>\n    <th>Type</th>\n  </tr>\n  <tr>\n    <td>transaction_id</td>\n    <td>int</td>\n  </tr>\n  <tr>\n    <td>customer_id</td>\n    <td>int</td>\n  </tr>\n  <tr>\n    <td>transaction_date</td>\n    <td>date</td>\n  </tr>\n  <tr>\n    <td>amount</td>\n    <td>decimal</td>\n  </tr>\n  <tr>\n    <td>transaction_type</td>\n    <td>varchar</td>\n  </tr>\n</table>\n\n<p>transaction_id is the unique identifier for this table.</p>\n<p>transaction_type can be either 'purchase' or 'refund'.</p>\n\n<h3>Task</h3>\n<p>\nFind loyal customers. A customer is considered loyal if they satisfy all of the following:\n</p>\n<ul>\n  <li>They have at least 3 purchase transactions.</li>\n  <li>Their activity period (from first to last transaction) is at least 30 days.</li>\n  <li>Their refund rate is less than 20%.</li>\n</ul>\n\n<p>\nRefund rate is the number of refund transactions divided by the total number of transactions\n(purchases plus refunds).\n</p>\n<p>\nReturn the result with customer_id sorted in ascending order.\n</p>\n\n<h3>Example Input</h3>\n\n<table>\n  <tr>\n    <th>transaction_id</th>\n    <th>customer_id</th>\n    <th>transaction_date</th>\n    <th>amount</th>\n    <th>transaction_type</th>\n  </tr>\n  <tr><td>1</td><td>101</td><td>2024-01-05</td><td>150.00</td><td>purchase</td></tr>\n  <tr><td>2</td><td>101</td><td>2024-01-15</td><td>200.00</td><td>purchase</td></tr>\n  <tr><td>3</td><td>101</td><td>2024-02-10</td><td>180.00</td><td>purchase</td></tr>\n  <tr><td>4</td><td>101</td><td>2024-02-20</td><td>250.00</td><td>purchase</td></tr>\n  <tr><td>5</td><td>102</td><td>2024-01-10</td><td>100.00</td><td>purchase</td></tr>\n  <tr><td>6</td><td>102</td><td>2024-01-12</td><td>120.00</td><td>purchase</td></tr>\n  <tr><td>7</td><td>102</td><td>2024-01-15</td><td>80.00</td><td>refund</td></tr>\n  <tr><td>8</td><td>102</td><td>2024-01-18</td><td>90.00</td><td>refund</td></tr>\n  <tr><td>9</td><td>102</td><td>2024-02-15</td><td>130.00</td><td>purchase</td></tr>\n  <tr><td>10</td><td>103</td><td>2024-01-01</td><td>500.00</td><td>purchase</td></tr>\n  <tr><td>11</td><td>103</td><td>2024-01-02</td><td>450.00</td><td>purchase</td></tr>\n  <tr><td>12</td><td>103</td><td>2024-01-03</td><td>400.00</td><td>purchase</td></tr>\n  <tr><td>13</td><td>104</td><td>2024-01-01</td><td>200.00</td><td>purchase</td></tr>\n  <tr><td>14</td><td>104</td><td>2024-02-01</td><td>250.00</td><td>purchase</td></tr>\n  <tr><td>15</td><td>104</td><td>2024-02-15</td><td>300.00</td><td>purchase</td></tr>\n  <tr><td>16</td><td>104</td><td>2024-03-01</td><td>350.00</td><td>purchase</td></tr>\n  <tr><td>17</td><td>104</td><td>2024-03-10</td><td>280.00</td><td>purchase</td></tr>\n  <tr><td>18</td><td>104</td><td>2024-03-15</td><td>100.00</td><td>refund</td></tr>\n</table>\n\n<h3>Example Output</h3>\n\n<table>\n  <tr>\n    <th>customer_id</th>\n  </tr>\n  <tr><td>101</td></tr>\n  <tr><td>104</td></tr>\n</table>\n\n<h3>Explanation</h3>\n<ul>\n  <li>Customer 101: 4 purchases, 0 refunds, refund rate 0%, active from 2024-01-05 to 2024-02-20 (46 days)  loyal.</li>\n  <li>Customer 102: 3 purchases, 2 refunds, refund rate 40%  not loyal.</li>\n  <li>Customer 103: 3 purchases, 0 refunds, active from 2024-01-01 to 2024-01-03 (2 days)  not loyal.</li>\n  <li>Customer 104: 5 purchases, 1 refund, refund rate about 16.67%, active from 2024-01-01 to 2024-03-15 (73 days)  loyal.</li>\n</ul>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "3716 Find Churn Risk Customers",
    "repo": "datix",
    "path": "3716-find-churn-risk-customers",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n-- Have been a subscriber for at least 60 days.\n-- Have performed at least one downgrade in their subscription history.\n-- Currently have an active subscription (their last event is not cancel).\n-- Their current plan revenue is less than 50% of their historical maximum plan revenue. : 9.9 < 0.5 * 29.9\n\n\nWITH get_least_60_days AS\n(\n  SELECT user_id,\n         MAX(event_date) - MIN(event_date) AS days_as_subscriber\n  FROM subscription_events\n  GROUP BY user_id\n  HAVING MAX(event_date) - MIN(event_date) >= 60\n),\nat_least_one_downgrade AS\n(\n   SELECT user_id\n   FROM subscription_events\n   WHERE event_type = 'downgrade'\n   GROUP BY user_id\n   HAVING COUNT(*) >= 1\n),\nas_active_plan AS\n(\n   SELECT user_id,\n          plan_name,\n          monthly_amount\n   FROM (\n        SELECT user_id,\n               event_date,\n               event_type,          -- FIX: include event_type to correctly detect cancellation\n               plan_name,\n               monthly_amount,      -- FIX: include monthly_amount to get current revenue\n               ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY event_date DESC) AS dt_rnk\n        FROM subscription_events\n   )\n   WHERE dt_rnk = 1\n     AND event_type <> 'cancel'     -- FIX: check active subscription using event_type, not plan_name\n),\njoin_data AS\n(\n    SELECT a.user_id,\n           c.plan_name AS current_plan,\n           c.monthly_amount AS current_monthly_amount,  -- FIX: current revenue from latest event\n           a.days_as_subscriber\n    FROM get_least_60_days a\n    JOIN at_least_one_downgrade b ON a.user_id = b.user_id\n    JOIN as_active_plan c ON b.user_id = c.user_id\n),\npartial_data AS\n(\n    SELECT a.user_id,\n           b.current_monthly_amount,      -- FIX: stop using MIN(monthly_amount) as current revenue\n           MAX(a.monthly_amount) AS max_historical_amount\n    FROM subscription_events a\n    JOIN join_data b ON a.user_id = b.user_id\n    GROUP BY a.user_id, b.current_monthly_amount\n    HAVING b.current_monthly_amount < 0.5 * MAX(a.monthly_amount) -- FIX: compare current vs max\n)\nSELECT a.user_id,\n       a.current_plan,\n       b.current_monthly_amount,\n       b.max_historical_amount,\n       a.days_as_subscriber\nFROM join_data a\nJOIN partial_data b ON a.user_id = b.user_id\nORDER BY a.days_as_subscriber DESC, a.user_id ASC;",
    "description": "<h2><a href=\"https://leetcode.com/problems/find-churn-risk-customers\">4103. Find Churn Risk Customers</a></h2><h3>Medium</h3><hr><p>Table: <code>subscription_events</code></p>\n\n<pre>\n+------------------+---------+\n| Column Name      | Type    | \n+------------------+---------+\n| event_id         | int     |\n| user_id          | int     |\n| event_date       | date    |\n| event_type       | varchar |\n| plan_name        | varchar |\n| monthly_amount   | decimal |\n+------------------+---------+\nevent_id is the unique identifier for this table.\nevent_type can be start, upgrade, downgrade, or cancel.\nplan_name can be basic, standard, premium, or NULL (when event_type is cancel).\nmonthly_amount represents the monthly subscription cost after this event.\nFor cancel events, monthly_amount is 0.\n</pre>\n\n<p>Write a solution to <strong>Find Churn Risk Customers</strong> - users who show warning signs before churning. A user is considered <b>churn risk customer</b>&nbsp;if they meet ALL the following criteria:</p>\n\n<ul>\n\t<li>Currently have an <strong>active subscription</strong> (their last event is not cancel).</li>\n\t<li>Have performed <strong>at least one</strong> downgrade in their subscription history.</li>\n\t<li>Their <strong>current plan revenue</strong> is less than <code>50%</code> of their historical maximum plan revenue.</li>\n\t<li>Have been a subscriber for <strong>at least</strong> <code>60</code> days.</li>\n</ul>\n\n<p>Return <em>the result table&nbsp;ordered by</em> <code>days_as_subscriber</code> <em>in <strong>descending</strong> order, then by</em> <code>user_id</code> <em>in <strong>ascending</strong> order</em>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong></p>\n\n<p>subscription_events table:</p>\n\n<pre class=\"example-io\">\n+----------+---------+------------+------------+-----------+----------------+\n| event_id | user_id | event_date | event_type | plan_name | monthly_amount |\n+----------+---------+------------+------------+-----------+----------------+\n| 1        | 501     | 2024-01-01 | start      | premium   | 29.99          |\n| 2        | 501     | 2024-02-15 | downgrade  | standard  | 19.99          |\n| 3        | 501     | 2024-03-20 | downgrade  | basic     | 9.99           |\n| 4        | 502     | 2024-01-05 | start      | standard  | 19.99          |\n| 5        | 502     | 2024-02-10 | upgrade    | premium   | 29.99          |\n| 6        | 502     | 2024-03-15 | downgrade  | basic     | 9.99           |\n| 7        | 503     | 2024-01-10 | start      | basic     | 9.99           |\n| 8        | 503     | 2024-02-20 | upgrade    | standard  | 19.99          |\n| 9        | 503     | 2024-03-25 | upgrade    | premium   | 29.99          |\n| 10       | 504     | 2024-01-15 | start      | premium   | 29.99          |\n| 11       | 504     | 2024-03-01 | downgrade  | standard  | 19.99          |\n| 12       | 504     | 2024-03-30 | cancel     | NULL      | 0.00           |\n| 13       | 505     | 2024-02-01 | start      | basic     | 9.99           |\n| 14       | 505     | 2024-02-28 | upgrade    | standard  | 19.99          |\n| 15       | 506     | 2024-01-20 | start      | premium   | 29.99          |\n| 16       | 506     | 2024-03-10 | downgrade  | basic     | 9.99           |\n+----------+---------+------------+------------+-----------+----------------+\n</pre>\n\n<p><strong>Output:</strong></p>\n\n<pre class=\"example-io\">\n+----------+--------------+------------------------+-----------------------+--------------------+\n| user_id  | current_plan | current_monthly_amount | max_historical_amount | days_as_subscriber |\n+----------+--------------+------------------------+-----------------------+--------------------+\n| 501      | basic        | 9.99                   | 29.99                 | 79                 |\n| 502      | basic        | 9.99                   | 29.99                 | 69                 |\n+----------+--------------+------------------------+-----------------------+--------------------+\n</pre>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li><strong>User 501</strong>:\n\n\t<ul>\n\t\t<li>Currently active: Last event is downgrade&nbsp;to basic (not cancelled)&nbsp;</li>\n\t\t<li>Has downgrades: Yes, 2 downgrades in history&nbsp;</li>\n\t\t<li>Current revenue (9.99) vs max (29.99): 9.99/29.99 = 33.3% (less than 50%)&nbsp;</li>\n\t\t<li>Days as subscriber: Jan 1 to Mar 20 = 79 days (at least 60)&nbsp;</li>\n\t\t<li>Result: <strong>Churn Risk Customer</strong></li>\n\t</ul>\n\t</li>\n\t<li><strong>User 502</strong>:\n\t<ul>\n\t\t<li>Currently active: Last event is downgrade&nbsp;to basic (not cancelled)&nbsp;</li>\n\t\t<li>Has downgrades: Yes, 1 downgrade in history&nbsp;</li>\n\t\t<li>Current revenue (9.99) vs max (29.99): 9.99/29.99 = 33.3% (less than 50%)&nbsp;</li>\n\t\t<li>Days as subscriber: Jan 5 to Mar 15 = 70 days (at least 60)&nbsp;</li>\n\t\t<li>Result: <strong>Churn Risk Customer</strong></li>\n\t</ul>\n\t</li>\n\t<li><strong>User 503</strong>:\n\t<ul>\n\t\t<li>Currently active: Last event is upgrade&nbsp;to premium (not cancelled)&nbsp;</li>\n\t\t<li>Has downgrades: No downgrades in history&nbsp;</li>\n\t\t<li>Result: <strong>Not at-risk</strong> (no downgrade history)</li>\n\t</ul>\n\t</li>\n\t<li><strong>User 504</strong>:\n\t<ul>\n\t\t<li>Currently active: Last event is cancel</li>\n\t\t<li>Result: <strong>Not at-risk</strong> (subscription cancelled)</li>\n\t</ul>\n\t</li>\n\t<li><strong>User 505</strong>:\n\t<ul>\n\t\t<li>Currently active: Last event is &#39;upgrade&#39; to standard (not cancelled)&nbsp;</li>\n\t\t<li>Has downgrades: No downgrades in history&nbsp;</li>\n\t\t<li>Result: <strong>Not at-risk</strong> (no downgrade history)</li>\n\t</ul>\n\t</li>\n\t<li><strong>User 506</strong>:\n\t<ul>\n\t\t<li>Currently active: Last event is downgrade&nbsp;to basic (not cancelled)&nbsp;</li>\n\t\t<li>Has downgrades: Yes, 1 downgrade in history&nbsp;</li>\n\t\t<li>Current revenue (9.99) vs max (29.99): 9.99/29.99 = 33.3% (less than 50%)&nbsp;</li>\n\t\t<li>Days as subscriber: Jan 20 to Mar 10 = 50 days (less than 60)&nbsp;</li>\n\t\t<li>Result: <strong>Not at-risk</strong> (insufficient subscription duration)</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Result table is ordered by days_as_subscriber DESC, then user_id ASC.</p>\n\n<p><strong>Note:</strong> days_as_subscriber is calculated from the first event date to the last event date for each user.</p>\n</div>\n",
    "tags": [
      "ORACLE"
    ]
  }
]