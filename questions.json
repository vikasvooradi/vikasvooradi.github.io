[
  {
    "platform": "DATIX",
    "title": "1.Staff Members Exceeding Supervisor Compensation",
    "repo": "datix",
    "path": "1.staff-members-exceeding-supervisor-compensation",
    "sqlCode": "/* Write your PL/SQL query statement below */\r\n\r\n/*\r\n\r\nExplanation:\r\n\r\np represents the staff member.\r\ns represents the supervisor of that staff member.\r\nWe join the table to itself on supervisorCode = staffCode to link each employee with their supervisor.\r\nThe WHERE clause filters only those staff whose payAmount is greater than their supervisor's payAmount.\r\n\r\n*/\r\n\r\nSELECT\r\n    p.fullname\r\nFROM\r\n         personnel p\r\n    JOIN personnel s ON p.supervisorcode = s.staffcode\r\nWHERE\r\n    p.payamount > s.payamount;\r\n\r\n\r\n\r\n",
    "description": "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body>\n\n<h1>1. Staff Members Exceeding Supervisor Compensation</h1>\n<h3>Level : Easy</h3><hr>\n<p>Database Schema</p>\n<p>Table: Personnel</p>\n\n<pre>\n+------------------+---------+\n| Field            | Format  |\n+------------------+---------+\n| staffCode        | int     |\n| fullName         | varchar |\n| payAmount        | int     |\n| supervisorCode   | int     |\n+------------------+---------+\n</pre>\n\n<p>staffCode serves as the primary key (unique identifier field) for this table.</p>\n<p>Every record in this table represents a staff member's unique code, complete name, compensation amount, and the unique code of their direct supervisor.</p>\n\n<p>Develop a query to retrieve all personnel whose compensation exceeds that of their direct supervisors.</p>\n\n<p>The output dataset may be arranged in any sequence.</p>\n\n<p>The output structure follows the pattern illustrated in the demonstration below.</p>\n\n<h2>Demonstration:</h2>\n\n<p>Input Dataset:</p>\n<p>Personnel table:</p>\n\n<pre>\n+-----------+----------+-----------+----------------+\n| staffCode | fullName | payAmount | supervisorCode |\n+-----------+----------+-----------+----------------+\n| 105       | Marcus   | 95000     | 203            |\n| 147       | Diana    | 72000     | 318            |\n| 203       | Rachel   | 88000     | Null           |\n| 318       | Kevin    | 110000    | Null           |\n+-----------+----------+-----------+----------------+\n</pre>\n\n<p>Expected Output:</p>\n\n<pre>\n+--------------+\n| StaffMember  |\n+--------------+\n| Marcus       |\n+--------------+\n</pre>\n\n<p>Explanation: Marcus is the only staff member whose compensation surpasses that of their supervisor.</p>\n\n</body>\n</html>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "2.Recurring Contact Addresses",
    "repo": "datix",
    "path": "2.recurring-contact-addresses",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nSELECT\n    address\nFROM\n    contact\nGROUP BY\n    address\nHAVING\n    COUNT(address) > 1;\n",
    "description": "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body>\n<h1>2. Recurring Contact Addresses</h1>\n<h3>Level : Easy</h3><hr>\n<p>Database Schema</p>\n<p>Table: Contact</p>\n<pre>\n+-----------------+---------+\n| Column Name     | Type    |\n+-----------------+---------+\n| contact_id      | int     |\n| address         | varchar |\n+-----------------+---------+\n</pre>\n<p>contact_id serves as the primary key (unique identifier column) for this table.</p>\n<p>Every record in this table includes a contact address. All addresses are stored in lowercase format.</p>\n<p>Develop a query to identify all contact addresses that appear more than once in the dataset. The address field is guaranteed to contain valid data with no NULL values.</p>\n<p>Your result set may be returned in any sequence.</p>\n<p>The output structure is demonstrated in the example below.</p>\n<h2>Example 1:</h2>\n<p>Input: </p>\n<p>Contact table:</p>\n<pre>\n+------------+------------------+\n| contact_id | address          |\n+------------+------------------+\n| 205        | mark@tech.io     |\n| 318        | sara@venture.net |\n| 429        | mark@tech.io     |\n+------------+------------------+\n</pre>\n<p>Output: </p>\n<pre>\n+------------------+\n| Address          |\n+------------------+\n| mark@tech.io     |\n+------------------+\n</pre>\n<p>Explanation: The address mark@tech.io occurs in multiple records within the Contact table.</p>\n</body>\n</html>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "3.Identify Operators With Enhanced Performance Metrics",
    "repo": "datix",
    "path": "3.identify-operators-with-enhanced-performance-metrics",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nWITH get_driver_in_both AS (\n    SELECT\n        operator_id\n    FROM\n        (\n            SELECT DISTINCT\n                operator_id,\n                CASE\n                    WHEN EXTRACT(MONTH FROM journey_date) BETWEEN 1 AND 6 THEN\n                        'F'\n                    ELSE\n                        'S'\n                END AS check_half\n            FROM\n                journeys\n        )\n    WHERE\n        check_half = 'F'\n    INTERSECT\n    SELECT\n        operator_id\n    FROM\n        (\n            SELECT DISTINCT\n                operator_id,\n                CASE\n                    WHEN EXTRACT(MONTH FROM journey_date) BETWEEN 1 AND 6 THEN\n                        'F'\n                    ELSE\n                        'S'\n                END AS check_half\n            FROM\n                journeys\n        )\n    WHERE\n        check_half = 'S'\n), get_fuel_cal_fuel_efficency AS (\n    SELECT\n        t.operator_id,\n        CASE\n            WHEN EXTRACT(MONTH FROM t.journey_date) BETWEEN 1 AND 6 THEN\n                'F'\n            ELSE\n                'S'\n        END                             AS check_half,\n        t.distance_miles / t.energy_usage AS fuel_cal\n    FROM\n             journeys t\n        JOIN get_driver_in_both b ON t.operator_id = b.operator_id\n), efficiency_improvement AS (\n    SELECT\n        operator_id,\n        round(AVG(\n            CASE\n                WHEN check_half = 'F' THEN\n                    fuel_cal\n            END\n        ),\n              2) AS first_half_avg,\n        round(AVG(\n            CASE\n                WHEN check_half = 'S' THEN\n                    fuel_cal\n            END\n        ),\n              2) AS second_half_avg,\n        AVG(\n            CASE\n                WHEN check_half = 'S' THEN\n                    fuel_cal\n            END\n        ) - AVG(\n            CASE\n                WHEN check_half = 'F' THEN\n                    fuel_cal\n            END\n        )      AS efficiency_improvement\n    FROM\n        get_fuel_cal_fuel_efficency\n    GROUP BY\n        operator_id\n)\nSELECT\n    a.operator_id,\n    a.operator_name,\n    e.first_half_avg,\n    e.second_half_avg,\n    round(e.efficiency_improvement,2) as efficiency_improvement\nFROM\n         operators a\n    JOIN efficiency_improvement e ON a.operator_id = e.operator_id\n    where e.second_half_avg > e.first_half_avg\nORDER BY\n    e.efficiency_improvement DESC,\n    a.operator_name ASC;\n",
    "description": "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body>\n<h1>3. Identify Operators with Enhanced Performance Metrics</h1>\n<h3>Medium</h3><hr>\n<p>Database Schema</p>\n<p>Database Schema</p>\n<p>Table: operators</p>\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| operator_id   | int     |\n| operator_name | varchar |\n+---------------+---------+\n</pre>\n<p>operator_id serves as the unique identifier for this table.</p>\n<p>Every record provides details about an individual operator.</p>\n<p>Table: journeys</p>\n<pre>\n+------------------+---------+\n| Column Name      | Type    |\n+------------------+---------+\n| journey_id       | int     |\n| operator_id      | int     |\n| journey_date     | date    |\n| distance_miles   | decimal |\n| energy_usage     | decimal |\n+------------------+---------+\n</pre>\n<p>journey_id serves as the unique identifier for this table.</p>\n<p>Every record captures a journey completed by an operator, documenting the distance covered and energy consumed during that journey.</p>\n<p>Develop a query to identify operators whose performance efficiency has shown improvement when comparing their average performance metrics between the initial six months and the latter six months of the year.</p>\n<p>Compute performance efficiency as distance_miles / energy_usage for every journey</p>\n<p>Initial period: January through June, Latter period: July through December</p>\n<p>Include exclusively operators who have completed journeys in both periods of the year</p>\n<p>Determine the efficiency enhancement as (latter_period_avg - initial_period_avg)</p>\n<p>Round all numerical values to 2 decimal places</p>\n<p>Return the result dataset sorted by efficiency enhancement in descending order, followed by operator name in ascending order.</p>\n<p>The output structure is demonstrated in the example below.</p>\n<h2>Example:</h2>\n<p>Input:</p>\n<p>operators table:</p>\n<pre>\n+-------------+------------------+\n| operator_id | operator_name    |\n+-------------+------------------+\n| 501         | Marcus Chen      |\n| 502         | Linda Rodriguez  |\n| 503         | James Anderson   |\n| 504         | Sarah Martinez   |\n| 505         | Robert Kim       |\n+-------------+------------------+\n</pre>\n<p>journeys table:</p>\n<pre>\n+------------+-------------+--------------+----------------+--------------+\n| journey_id | operator_id | journey_date | distance_miles | energy_usage |\n+------------+-------------+--------------+----------------+--------------+\n| 301        | 501         | 2023-03-08   | 185.7          | 15.8         |\n| 302        | 501         | 2023-04-22   | 295.3          | 24.1         |\n| 303        | 501         | 2023-09-14   | 220.6          | 16.2         |\n| 304        | 501         | 2023-10-28   | 265.4          | 18.3         |\n| 305        | 502         | 2023-02-05   | 147.8          | 13.2         |\n| 306        | 502         | 2023-05-19   | 368.5          | 32.4         |\n| 307        | 502         | 2023-11-07   | 294.7          | 22.1         |\n| 308        | 503         | 2023-04-16   | 118.2          | 12.5         |\n| 309        | 503         | 2023-06-23   | 132.9          | 13.5         |\n| 310        | 504         | 2023-08-26   | 236.1          | 18.9         |\n| 311        | 504         | 2023-12-03   | 206.5          | 16.2         |\n| 312        | 505         | 2023-03-31   | 162.3          | 16.9         |\n+------------+-------------+--------------+----------------+--------------+\n</pre>\n<p>Output:</p>\n<pre>\n+-------------+------------------+-------------------+--------------------+---------------------------+\n| operator_id | operator_name    | initial_period_avg | latter_period_avg | efficiency_enhancement    |\n+-------------+------------------+-------------------+--------------------+---------------------------+\n| 501         | Marcus Chen      | 12                | 14.06              | 2.06                      |\n| 502         | Linda Rodriguez  | 11.29             | 13.33              | 2.05                      |\n+-------------+------------------+-------------------+--------------------+---------------------------+\n</pre>\n\n<h2>Explanation</h2>\n\n<h3>Marcus Chen (operator_id = 501)</h3>\n\n<p>\n<strong>Initial period journeys (Jan–Jun):</strong><br>\nMar 8: 185.7 ÷ 15.8 = 11.75<br>\nApr 22: 295.3 ÷ 24.1 = 12.25\n</p>\n\n<p>\n<strong>Initial period average efficiency:</strong><br>\n(11.75 + 12.25) ÷ 2 = <strong>12.00</strong>\n</p>\n\n<p>\n<strong>Latter period journeys (Jul–Dec):</strong><br>\nSep 14: 220.6 ÷ 16.2 = 13.62<br>\nOct 28: 265.4 ÷ 18.3 = 14.50\n</p>\n\n<p>\n<strong>Latter period average efficiency:</strong><br>\n(13.62 + 14.50) ÷ 2 = <strong>14.06</strong>\n</p>\n\n<p>\n<strong>Efficiency enhancement:</strong><br>\n14.06 − 12.00 = <strong>2.06</strong>\n</p>\n\n<hr>\n\n<h3>Linda Rodriguez (operator_id = 502)</h3>\n\n<p>\n<strong>Initial period journeys:</strong><br>\nFeb 5: 147.8 ÷ 13.2 = 11.20<br>\nMay 19: 368.5 ÷ 32.4 = 11.37\n</p>\n\n<p>\n<strong>Initial period average efficiency:</strong><br>\n(11.20 + 11.37) ÷ 2 = <strong>11.29</strong>\n</p>\n\n<p>\n<strong>Latter period journeys:</strong><br>\nNov 7: 294.7 ÷ 22.1 = 13.33\n</p>\n\n<p>\n<strong>Latter period average efficiency:</strong><br>\n<strong>13.33</strong>\n</p>\n\n<p>\n<strong>Efficiency enhancement:</strong><br>\n13.33 − 11.29 = <strong>2.05</strong>\n</p>\n\n<hr>\n\n<h3>Operators Not Included</h3>\n<ul>\n    <li>James Anderson (operator_id = 503): Journeys only in the initial period (Apr, Jun)</li>\n    <li>Sarah Martinez (operator_id = 504): Journeys only in the latter period (Aug, Dec)</li>\n    <li>Robert Kim (operator_id = 505): Journeys only in the initial period (Mar)</li>\n</ul>\n\n<p>\nThe output dataset is arranged by efficiency enhancement in descending order, followed by operator name in ascending order.\n</p>\n\n<br>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "4.Identify Personnel With Progressive Performance Growth",
    "repo": "datix",
    "path": "4.identify-personnel-with-progressive-performance-growth",
    "sqlCode": "select * from dual;\n",
    "description": "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body>\n\n<h1>4. Identify Personnel with Progressive Performance Growth</h1>\n\n<h3>Medium</h3><hr>\n<p>SQL Schema</p>\n\n<h2>Table: personnel</h2>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| staff_id    | int     |\n| full_name   | varchar |\n+-------------+---------+\n</pre>\n\n<p>staff_id serves as the primary key for this table.</p>\n<p>Each record contains details about a staff member.</p>\n\n<h2>Table: evaluation_records</h2>\n\n<pre>\n+------------------+------+\n| Column Name      | Type |\n+------------------+------+\n| evaluation_id    | int  |\n| staff_id         | int  |\n| assessment_date  | date |\n| score            | int  |\n+------------------+------+\n</pre>\n\n<p>evaluation_id serves as the primary key for this table.</p>\n<p>Each record captures a performance evaluation for a staff member. Scores range from 1 to 5, with 5 representing outstanding performance and 1 indicating underperformance.</p>\n\n<p>Compose a query to identify staff members whose performance has demonstrated continuous upward progression across their three most recent evaluations.</p>\n\n<p>A staff member must possess a minimum of 3 evaluations to qualify for consideration</p>\n<p>The three most recent evaluations must exhibit strictly ascending scores (each subsequent assessment exceeding the prior one)</p>\n<p>Utilize the three latest evaluations determined by assessment_date for each staff member</p>\n<p>Compute the growth_metric as the numerical difference between the most recent score and the oldest score within the latest 3 evaluations</p>\n\n<p>Present the result set sorted by growth_metric in descending sequence, followed by full_name in ascending sequence.</p>\n\n<p>The result format is demonstrated in the example below.</p>\n\n<h2>Example:</h2>\n\n<p>Input:</p>\n\n<p>personnel table:</p>\n\n<pre>\n+----------+-------------------+\n| staff_id | full_name         |\n+----------+-------------------+\n| 203      | Marcus Chen       |\n| 417      | Sofia Rodriguez   |\n| 528      | Liam O'Connor     |\n| 635      | Priya Patel       |\n| 749      | James Anderson    |\n+----------+-------------------+\n</pre>\n\n<p>evaluation_records table:</p>\n\n<pre>\n+---------------+----------+-----------------+-------+\n| evaluation_id | staff_id | assessment_date | score |\n+---------------+----------+-----------------+-------+\n| 891           | 203      | 2023-02-08      | 1     |\n| 892           | 203      | 2023-05-12      | 2     |\n| 893           | 203      | 2023-08-19      | 3     |\n| 894           | 203      | 2023-11-23      | 4     |\n| 895           | 417      | 2023-03-14      | 2     |\n| 896           | 417      | 2023-06-18      | 1     |\n| 897           | 417      | 2023-09-22      | 3     |\n| 898           | 417      | 2023-12-05      | 4     |\n| 899           | 528      | 2023-01-25      | 2     |\n| 900           | 528      | 2023-04-29      | 3     |\n| 901           | 528      | 2023-07-31      | 4     |\n| 902           | 528      | 2023-10-28      | 5     |\n| 903           | 635      | 2023-02-17      | 3     |\n| 904           | 635      | 2023-05-21      | 3     |\n| 905           | 635      | 2023-08-24      | 3     |\n| 906           | 749      | 2023-03-06      | 4     |\n| 907           | 749      | 2023-06-09      | 3     |\n+---------------+----------+-----------------+-------+\n</pre>\n\n<p>Output:</p>\n\n<pre>\n+----------+-------------------+---------------+\n| staff_id | full_name         | growth_metric |\n+----------+-------------------+---------------+\n| 417      | Sofia Rodriguez   | 3             |\n| 528      | Liam O'Connor     | 2             |\n| 203      | Marcus Chen       | 2             |\n+----------+-------------------+---------------+\n</pre>\n\n<p>Explanation:</p>\n\n<p><strong>Marcus Chen (staff_id = 203):</strong></p>\n<ul>\n<li>Total evaluations: 4</li>\n<li>All evaluation dates and scores:\n  <ul>\n    <li>2023-02-08: score = 1</li>\n    <li>2023-05-12: score = 2</li>\n    <li>2023-08-19: score = 3</li>\n    <li>2023-11-23: score = 4</li>\n  </ul>\n</li>\n<li>Latest 3 evaluations (by assessment_date):\n  <ul>\n    <li>1st oldest: 2023-05-12 with score = 2</li>\n    <li>2nd: 2023-08-19 with score = 3</li>\n    <li>3rd most recent: 2023-11-23 with score = 4</li>\n  </ul>\n</li>\n<li>Checking strict progression: 2 < 3 < 4 ✓ (strictly increasing)</li>\n<li>Growth metric calculation: 4 - 2 = 2</li>\n<li><strong>Result: INCLUDED</strong></li>\n</ul>\n\n<p><strong>Sofia Rodriguez (staff_id = 417):</strong></p>\n<ul>\n<li>Total evaluations: 4</li>\n<li>All evaluation dates and scores:\n  <ul>\n    <li>2023-03-14: score = 2</li>\n    <li>2023-06-18: score = 1</li>\n    <li>2023-09-22: score = 3</li>\n    <li>2023-12-05: score = 4</li>\n  </ul>\n</li>\n<li>Latest 3 evaluations (by assessment_date):\n  <ul>\n    <li>1st oldest: 2023-06-18 with score = 1</li>\n    <li>2nd: 2023-09-22 with score = 3</li>\n    <li>3rd most recent: 2023-12-05 with score = 4</li>\n  </ul>\n</li>\n<li>Checking strict progression: 1 < 3 < 4 ✓ (strictly increasing)</li>\n<li>Growth metric calculation: 4 - 1 = 3</li>\n<li><strong>Result: INCLUDED</strong></li>\n</ul>\n\n<p><strong>Liam O'Connor (staff_id = 528):</strong></p>\n<ul>\n<li>Total evaluations: 4</li>\n<li>All evaluation dates and scores:\n  <ul>\n    <li>2023-01-25: score = 2</li>\n    <li>2023-04-29: score = 3</li>\n    <li>2023-07-31: score = 4</li>\n    <li>2023-10-28: score = 5</li>\n  </ul>\n</li>\n<li>Latest 3 evaluations (by assessment_date):\n  <ul>\n    <li>1st oldest: 2023-04-29 with score = 3</li>\n    <li>2nd: 2023-07-31 with score = 4</li>\n    <li>3rd most recent: 2023-10-28 with score = 5</li>\n  </ul>\n</li>\n<li>Checking strict progression: 3 < 4 < 5 ✓ (strictly increasing)</li>\n<li>Growth metric calculation: 5 - 3 = 2</li>\n<li><strong>Result: INCLUDED</strong></li>\n</ul>\n\n<p><strong>Priya Patel (staff_id = 635):</strong></p>\n<ul>\n<li>Total evaluations: 3</li>\n<li>All evaluation dates and scores:\n  <ul>\n    <li>2023-02-17: score = 3</li>\n    <li>2023-05-21: score = 3</li>\n    <li>2023-08-24: score = 3</li>\n  </ul>\n</li>\n<li>Latest 3 evaluations (by assessment_date):\n  <ul>\n    <li>1st oldest: 2023-02-17 with score = 3</li>\n    <li>2nd: 2023-05-21 with score = 3</li>\n    <li>3rd most recent: 2023-08-24 with score = 3</li>\n  </ul>\n</li>\n<li>Checking strict progression: 3 = 3 = 3 ✗ (NOT strictly increasing, no progression)</li>\n<li><strong>Result: EXCLUDED (scores are equal, not increasing)</strong></li>\n</ul>\n\n<p><strong>James Anderson (staff_id = 749):</strong></p>\n<ul>\n<li>Total evaluations: 2</li>\n<li>All evaluation dates and scores:\n  <ul>\n    <li>2023-03-06: score = 4</li>\n    <li>2023-06-09: score = 3</li>\n  </ul>\n</li>\n<li>Has only 2 evaluations, but requirement is minimum of 3 evaluations</li>\n<li><strong>Result: EXCLUDED (insufficient evaluation records)</strong></li>\n</ul>\n\n<p><strong>Final Result Ordering:</strong></p>\n<ul>\n<li>Sort by growth_metric descending: Sofia Rodriguez (3), then Liam O'Connor (2) and Marcus Chen (2)</li>\n<li>For tied growth_metric values (both 2), sort by full_name ascending: \"Liam O'Connor\" comes before \"Marcus Chen\" alphabetically</li>\n<li>Final order: Sofia Rodriguez (3), Liam O'Connor (2), Marcus Chen (2)</li>\n</ul>\n\n</body>\n</html>\n",
    "tags": [
      "ORACLE"
    ]
  }
]