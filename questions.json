[
  {
    "platform": "DATIX",
    "title": "1.Staff Members Exceeding Supervisor Compensation",
    "repo": "datix",
    "path": "1.staff-members-exceeding-supervisor-compensation",
    "sqlCode": "/* Write your PL/SQL query statement below */\r\n\r\n/*\r\n\r\nExplanation:\r\n\r\np represents the staff member.\r\ns represents the supervisor of that staff member.\r\nWe join the table to itself on supervisorCode = staffCode to link each employee with their supervisor.\r\nThe WHERE clause filters only those staff whose payAmount is greater than their supervisor's payAmount.\r\n\r\n*/\r\n\r\nSELECT\r\n    p.fullname\r\nFROM\r\n         personnel p\r\n    JOIN personnel s ON p.supervisorcode = s.staffcode\r\nWHERE\r\n    p.payamount > s.payamount;\r\n\r\n\r\n\r\n",
    "description": "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body>\n\n<h1>1. Staff Members Exceeding Supervisor Compensation</h1>\n<h3>Level : Easy</h3><hr>\n<p>Database Schema</p>\n<p>Table: Personnel</p>\n\n<pre>\n+------------------+---------+\n| Field            | Format  |\n+------------------+---------+\n| staffCode        | int     |\n| fullName         | varchar |\n| payAmount        | int     |\n| supervisorCode   | int     |\n+------------------+---------+\n</pre>\n\n<p>staffCode serves as the primary key (unique identifier field) for this table.</p>\n<p>Every record in this table represents a staff member's unique code, complete name, compensation amount, and the unique code of their direct supervisor.</p>\n\n<p>Develop a query to retrieve all personnel whose compensation exceeds that of their direct supervisors.</p>\n\n<p>The output dataset may be arranged in any sequence.</p>\n\n<p>The output structure follows the pattern illustrated in the demonstration below.</p>\n\n<h2>Demonstration:</h2>\n\n<p>Input Dataset:</p>\n<p>Personnel table:</p>\n\n<pre>\n+-----------+----------+-----------+----------------+\n| staffCode | fullName | payAmount | supervisorCode |\n+-----------+----------+-----------+----------------+\n| 105       | Marcus   | 95000     | 203            |\n| 147       | Diana    | 72000     | 318            |\n| 203       | Rachel   | 88000     | Null           |\n| 318       | Kevin    | 110000    | Null           |\n+-----------+----------+-----------+----------------+\n</pre>\n\n<p>Expected Output:</p>\n\n<pre>\n+--------------+\n| StaffMember  |\n+--------------+\n| Marcus       |\n+--------------+\n</pre>\n\n<p>Explanation: Marcus is the only staff member whose compensation surpasses that of their supervisor.</p>\n\n</body>\n</html>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "2.Recurring Contact Addresses",
    "repo": "datix",
    "path": "2.recurring-contact-addresses",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\nSELECT\n    address\nFROM\n    contact\nGROUP BY\n    address\nHAVING\n    COUNT(address) > 1;\n",
    "description": "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body>\n<h1>2. Recurring Contact Addresses</h1>\n<h3>Level : Easy</h3><hr>\n<p>Database Schema</p>\n<p>Table: Contact</p>\n<pre>\n+-----------------+---------+\n| Column Name     | Type    |\n+-----------------+---------+\n| contact_id      | int     |\n| address         | varchar |\n+-----------------+---------+\n</pre>\n<p>contact_id serves as the primary key (unique identifier column) for this table.</p>\n<p>Every record in this table includes a contact address. All addresses are stored in lowercase format.</p>\n<p>Develop a query to identify all contact addresses that appear more than once in the dataset. The address field is guaranteed to contain valid data with no NULL values.</p>\n<p>Your result set may be returned in any sequence.</p>\n<p>The output structure is demonstrated in the example below.</p>\n<h2>Example 1:</h2>\n<p>Input: </p>\n<p>Contact table:</p>\n<pre>\n+------------+------------------+\n| contact_id | address          |\n+------------+------------------+\n| 205        | mark@tech.io     |\n| 318        | sara@venture.net |\n| 429        | mark@tech.io     |\n+------------+------------------+\n</pre>\n<p>Output: </p>\n<pre>\n+------------------+\n| Address          |\n+------------------+\n| mark@tech.io     |\n+------------------+\n</pre>\n<p>Explanation: The address mark@tech.io occurs in multiple records within the Contact table.</p>\n</body>\n</html>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "3.Identify Operators With Enhanced Performance Metrics",
    "repo": "datix",
    "path": "3.identify-operators-with-enhanced-performance-metrics",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nWITH get_driver_in_both AS (\n    SELECT\n        operator_id\n    FROM\n        (\n            SELECT DISTINCT\n                operator_id,\n                CASE\n                    WHEN EXTRACT(MONTH FROM journey_date) BETWEEN 1 AND 6 THEN\n                        'F'\n                    ELSE\n                        'S'\n                END AS check_half\n            FROM\n                journeys\n        )\n    WHERE\n        check_half = 'F'\n    INTERSECT\n    SELECT\n        operator_id\n    FROM\n        (\n            SELECT DISTINCT\n                operator_id,\n                CASE\n                    WHEN EXTRACT(MONTH FROM journey_date) BETWEEN 1 AND 6 THEN\n                        'F'\n                    ELSE\n                        'S'\n                END AS check_half\n            FROM\n                journeys\n        )\n    WHERE\n        check_half = 'S'\n), get_fuel_cal_fuel_efficency AS (\n    SELECT\n        t.operator_id,\n        CASE\n            WHEN EXTRACT(MONTH FROM t.journey_date) BETWEEN 1 AND 6 THEN\n                'F'\n            ELSE\n                'S'\n        END                             AS check_half,\n        t.distance_miles / t.energy_usage AS fuel_cal\n    FROM\n             journeys t\n        JOIN get_driver_in_both b ON t.operator_id = b.operator_id\n), efficiency_improvement AS (\n    SELECT\n        operator_id,\n        round(AVG(\n            CASE\n                WHEN check_half = 'F' THEN\n                    fuel_cal\n            END\n        ),\n              2) AS first_half_avg,\n        round(AVG(\n            CASE\n                WHEN check_half = 'S' THEN\n                    fuel_cal\n            END\n        ),\n              2) AS second_half_avg,\n        AVG(\n            CASE\n                WHEN check_half = 'S' THEN\n                    fuel_cal\n            END\n        ) - AVG(\n            CASE\n                WHEN check_half = 'F' THEN\n                    fuel_cal\n            END\n        )      AS efficiency_improvement\n    FROM\n        get_fuel_cal_fuel_efficency\n    GROUP BY\n        operator_id\n)\nSELECT\n    a.operator_id,\n    a.operator_name,\n    e.first_half_avg,\n    e.second_half_avg,\n    round(e.efficiency_improvement,2) as efficiency_improvement\nFROM\n         operators a\n    JOIN efficiency_improvement e ON a.operator_id = e.operator_id\n    where e.second_half_avg > e.first_half_avg\nORDER BY\n    e.efficiency_improvement DESC,\n    a.operator_name ASC;\n",
    "description": "<!DOCTYPE html>\n<html>\n<head>\n</head>\n<body>\n<h1>3. Identify Operators with Enhanced Performance Metrics</h1>\n<h3>Medium</h3><hr>\n<p>Database Schema</p>\n<p>Database Schema</p>\n<p>Table: operators</p>\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| operator_id   | int     |\n| operator_name | varchar |\n+---------------+---------+\n</pre>\n<p>operator_id serves as the unique identifier for this table.</p>\n<p>Every record provides details about an individual operator.</p>\n<p>Table: journeys</p>\n<pre>\n+------------------+---------+\n| Column Name      | Type    |\n+------------------+---------+\n| journey_id       | int     |\n| operator_id      | int     |\n| journey_date     | date    |\n| distance_miles   | decimal |\n| energy_usage     | decimal |\n+------------------+---------+\n</pre>\n<p>journey_id serves as the unique identifier for this table.</p>\n<p>Every record captures a journey completed by an operator, documenting the distance covered and energy consumed during that journey.</p>\n<p>Develop a query to identify operators whose performance efficiency has shown improvement when comparing their average performance metrics between the initial six months and the latter six months of the year.</p>\n<p>Compute performance efficiency as distance_miles / energy_usage for every journey</p>\n<p>Initial period: January through June, Latter period: July through December</p>\n<p>Include exclusively operators who have completed journeys in both periods of the year</p>\n<p>Determine the efficiency enhancement as (latter_period_avg - initial_period_avg)</p>\n<p>Round all numerical values to 2 decimal places</p>\n<p>Return the result dataset sorted by efficiency enhancement in descending order, followed by operator name in ascending order.</p>\n<p>The output structure is demonstrated in the example below.</p>\n<h2>Example:</h2>\n<p>Input:</p>\n<p>operators table:</p>\n<pre>\n+-------------+------------------+\n| operator_id | operator_name    |\n+-------------+------------------+\n| 501         | Marcus Chen      |\n| 502         | Linda Rodriguez  |\n| 503         | James Anderson   |\n| 504         | Sarah Martinez   |\n| 505         | Robert Kim       |\n+-------------+------------------+\n</pre>\n<p>journeys table:</p>\n<pre>\n+------------+-------------+--------------+----------------+--------------+\n| journey_id | operator_id | journey_date | distance_miles | energy_usage |\n+------------+-------------+--------------+----------------+--------------+\n| 301        | 501         | 2023-03-08   | 185.7          | 15.8         |\n| 302        | 501         | 2023-04-22   | 295.3          | 24.1         |\n| 303        | 501         | 2023-09-14   | 220.6          | 16.2         |\n| 304        | 501         | 2023-10-28   | 265.4          | 18.3         |\n| 305        | 502         | 2023-02-05   | 147.8          | 13.2         |\n| 306        | 502         | 2023-05-19   | 368.5          | 32.4         |\n| 307        | 502         | 2023-11-07   | 294.7          | 22.1         |\n| 308        | 503         | 2023-04-16   | 118.2          | 12.5         |\n| 309        | 503         | 2023-06-23   | 132.9          | 13.5         |\n| 310        | 504         | 2023-08-26   | 236.1          | 18.9         |\n| 311        | 504         | 2023-12-03   | 206.5          | 16.2         |\n| 312        | 505         | 2023-03-31   | 162.3          | 16.9         |\n+------------+-------------+--------------+----------------+--------------+\n</pre>\n<p>Output:</p>\n<pre>\n+-------------+------------------+-------------------+--------------------+---------------------------+\n| operator_id | operator_name    | initial_period_avg | latter_period_avg | efficiency_enhancement    |\n+-------------+------------------+-------------------+--------------------+---------------------------+\n| 501         | Marcus Chen      | 12                | 14.06              | 2.06                      |\n| 502         | Linda Rodriguez  | 11.29             | 13.33              | 2.05                      |\n+-------------+------------------+-------------------+--------------------+---------------------------+\n</pre>\n\n<h2>Explanation</h2>\n\n<h3>Marcus Chen (operator_id = 501)</h3>\n\n<p>\n<strong>Initial period journeys (Jan–Jun):</strong><br>\nMar 8: 185.7 ÷ 15.8 = 11.75<br>\nApr 22: 295.3 ÷ 24.1 = 12.25\n</p>\n\n<p>\n<strong>Initial period average efficiency:</strong><br>\n(11.75 + 12.25) ÷ 2 = <strong>12.00</strong>\n</p>\n\n<p>\n<strong>Latter period journeys (Jul–Dec):</strong><br>\nSep 14: 220.6 ÷ 16.2 = 13.62<br>\nOct 28: 265.4 ÷ 18.3 = 14.50\n</p>\n\n<p>\n<strong>Latter period average efficiency:</strong><br>\n(13.62 + 14.50) ÷ 2 = <strong>14.06</strong>\n</p>\n\n<p>\n<strong>Efficiency enhancement:</strong><br>\n14.06 − 12.00 = <strong>2.06</strong>\n</p>\n\n<hr>\n\n<h3>Linda Rodriguez (operator_id = 502)</h3>\n\n<p>\n<strong>Initial period journeys:</strong><br>\nFeb 5: 147.8 ÷ 13.2 = 11.20<br>\nMay 19: 368.5 ÷ 32.4 = 11.37\n</p>\n\n<p>\n<strong>Initial period average efficiency:</strong><br>\n(11.20 + 11.37) ÷ 2 = <strong>11.29</strong>\n</p>\n\n<p>\n<strong>Latter period journeys:</strong><br>\nNov 7: 294.7 ÷ 22.1 = 13.33\n</p>\n\n<p>\n<strong>Latter period average efficiency:</strong><br>\n<strong>13.33</strong>\n</p>\n\n<p>\n<strong>Efficiency enhancement:</strong><br>\n13.33 − 11.29 = <strong>2.05</strong>\n</p>\n\n<hr>\n\n<h3>Operators Not Included</h3>\n<ul>\n    <li>James Anderson (operator_id = 503): Journeys only in the initial period (Apr, Jun)</li>\n    <li>Sarah Martinez (operator_id = 504): Journeys only in the latter period (Aug, Dec)</li>\n    <li>Robert Kim (operator_id = 505): Journeys only in the initial period (Mar)</li>\n</ul>\n\n<p>\nThe output dataset is arranged by efficiency enhancement in descending order, followed by operator name in ascending order.\n</p>\n\n<br>\n",
    "tags": [
      "ORACLE"
    ]
  },
  {
    "platform": "DATIX",
    "title": "3580 Find Consistently Improving Employees",
    "repo": "datix",
    "path": "3580-find-consistently-improving-employees",
    "sqlCode": "/* Write your PL/SQL query statement below */\n\n\nWITH data AS (\n    SELECT\n        employee_id,\n        lead_2 - rating AS improvement_score\n    FROM\n        (\n            SELECT\n                employee_id,\n                review_date,\n                rating,\n                LEAD(rating, 1)\n                OVER(PARTITION BY employee_id\n                     ORDER BY\n                         review_date\n                ) AS lead_1,\n                LEAD(rating, 2)\n                OVER(PARTITION BY employee_id\n                     ORDER BY\n                         review_date\n                ) AS lead_2\n            FROM\n                (\n                    SELECT\n                        employee_id,\n                        review_date,\n                        rating,\n                        ROW_NUMBER()\n                        OVER(PARTITION BY employee_id\n                             ORDER BY\n                                 review_date DESC, rating DESC\n                        )                              AS rnk_rvt,\n                        COUNT(*)\n                        OVER(PARTITION BY employee_id) AS grp_cnt\n                    FROM\n                        performance_reviews\n                )\n            WHERE\n                    grp_cnt >= 3\n                AND rnk_rvt <= 3\n        )\n    WHERE\n        ( rating IS NOT NULL\n          AND lead_1 IS NOT NULL\n          AND lead_2 IS NOT NULL )\n        AND ( lead_2 > lead_1\n              AND lead_1 > rating )\n)\nSELECT\n    e.employee_id,\n    e.name,\n    d.improvement_score\nFROM\n         data d\n    JOIN employees e ON d.employee_id = e.employee_id\nORDER BY\n    d.improvement_score DESC,\n    e.name ASC;\n",
    "description": "<h2><a href=\"https://leetcode.com/problems/find-consistently-improving-employees\">3921. Find Consistently Improving Employees</a></h2><h3>Medium</h3><hr><p>Table: <code>employees</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| employee_id | int     |\n| name        | varchar |\n+-------------+---------+\nemployee_id is the unique identifier for this table.\nEach row contains information about an employee.\n</pre>\n\n<p>Table: <code>performance_reviews</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| review_id   | int  |\n| employee_id | int  |\n| review_date | date |\n| rating      | int  |\n+-------------+------+\nreview_id is the unique identifier for this table.\nEach row represents a performance review for an employee. The rating is on a scale of 1-5 where 5 is excellent and 1 is poor.\n</pre>\n\n<p>Write a solution to find employees who have consistently improved their performance over <strong>their last three reviews</strong>.</p>\n\n<ul>\n\t<li>An employee must have <strong>at least </strong><code>3</code><strong> review</strong> to be considered</li>\n\t<li>The employee&#39;s <strong>last </strong><code>3</code><strong> reviews</strong> must show <strong>strictly increasing ratings</strong> (each review better than the previous)</li>\n\t<li>Use the most recent <code>3</code> reviews based on <code>review_date</code> for each employee</li>\n\t<li>Calculate the <strong>improvement score</strong> as the difference between the latest rating and the earliest rating among the last <code>3</code> reviews</li>\n</ul>\n\n<p>Return <em>the result table ordered by <strong>improvement score</strong> in <strong>descending</strong> order, then by <strong>name</strong> in <strong>ascending</strong> order</em>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong></p>\n\n<p>employees table:</p>\n\n<pre class=\"example-io\">\n+-------------+----------------+\n| employee_id | name           |\n+-------------+----------------+\n| 1           | Alice Johnson  |\n| 2           | Bob Smith      |\n| 3           | Carol Davis    |\n| 4           | David Wilson   |\n| 5           | Emma Brown     |\n+-------------+----------------+\n</pre>\n\n<p>performance_reviews table:</p>\n\n<pre class=\"example-io\">\n+-----------+-------------+-------------+--------+\n| review_id | employee_id | review_date | rating |\n+-----------+-------------+-------------+--------+\n| 1         | 1           | 2023-01-15  | 2      |\n| 2         | 1           | 2023-04-15  | 3      |\n| 3         | 1           | 2023-07-15  | 4      |\n| 4         | 1           | 2023-10-15  | 5      |\n| 5         | 2           | 2023-02-01  | 3      |\n| 6         | 2           | 2023-05-01  | 2      |\n| 7         | 2           | 2023-08-01  | 4      |\n| 8         | 2           | 2023-11-01  | 5      |\n| 9         | 3           | 2023-03-10  | 1      |\n| 10        | 3           | 2023-06-10  | 2      |\n| 11        | 3           | 2023-09-10  | 3      |\n| 12        | 3           | 2023-12-10  | 4      |\n| 13        | 4           | 2023-01-20  | 4      |\n| 14        | 4           | 2023-04-20  | 4      |\n| 15        | 4           | 2023-07-20  | 4      |\n| 16        | 5           | 2023-02-15  | 3      |\n| 17        | 5           | 2023-05-15  | 2      |\n+-----------+-------------+-------------+--------+\n</pre>\n\n<p><strong>Output:</strong></p>\n\n<pre class=\"example-io\">\n+-------------+----------------+-------------------+\n| employee_id | name           | improvement_score |\n+-------------+----------------+-------------------+\n| 2           | Bob Smith      | 3                 |\n| 1           | Alice Johnson  | 2                 |\n| 3           | Carol Davis    | 2                 |\n+-------------+----------------+-------------------+\n</pre>\n\n<p><strong>Explanation:</strong></p>\n\n<ul>\n\t<li><strong>Alice Johnson (employee_id = 1):</strong>\n\n\t<ul>\n\t\t<li>Has 4 reviews with ratings: 2, 3, 4, 5</li>\n\t\t<li>Last 3 reviews (by date): 2023-04-15 (3), 2023-07-15 (4), 2023-10-15 (5)</li>\n\t\t<li>Ratings are strictly increasing: 3 &rarr; 4 &rarr; 5</li>\n\t\t<li>Improvement score: 5 - 3 = 2</li>\n\t</ul>\n\t</li>\n\t<li><strong>Carol Davis (employee_id = 3):</strong>\n\t<ul>\n\t\t<li>Has 4 reviews with ratings: 1, 2, 3, 4</li>\n\t\t<li>Last 3 reviews (by date): 2023-06-10 (2), 2023-09-10 (3), 2023-12-10 (4)</li>\n\t\t<li>Ratings are strictly increasing: 2 &rarr; 3 &rarr; 4</li>\n\t\t<li>Improvement score: 4 - 2 = 2</li>\n\t</ul>\n\t</li>\n\t<li><strong>Bob Smith (employee_id = 2):</strong>\n\t<ul>\n\t\t<li>Has 4 reviews with ratings: 3, 2, 4, 5</li>\n\t\t<li>Last 3 reviews (by date): 2023-05-01 (2), 2023-08-01 (4), 2023-11-01 (5)</li>\n\t\t<li>Ratings are strictly increasing: 2 &rarr; 4 &rarr; 5</li>\n\t\t<li>Improvement score: 5 - 2 = 3</li>\n\t</ul>\n\t</li>\n\t<li><strong>Employees not included:</strong>\n\t<ul>\n\t\t<li>David Wilson (employee_id = 4): Last 3 reviews are all 4 (no improvement)</li>\n\t\t<li>Emma Brown (employee_id = 5): Only has 2 reviews (needs at least 3)</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>The output table is ordered by improvement_score in descending order, then by name in ascending order.</p>\n</div>\n",
    "tags": [
      "ORACLE"
    ]
  }
]